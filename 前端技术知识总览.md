# 参照表

## HTTP Content-type对照表

| 文件扩展名                          | Content-Type(Mime-Type)                 | 文件扩展名 | Content-Type(Mime-Type)             |
| :---------------------------------- | :-------------------------------------- | :--------- | :---------------------------------- |
| .*（ 二进制流，不知道下载文件类型） | application/octet-stream                | .tif       | image/tiff                          |
| .001                                | application/x-001                       | .301       | application/x-301                   |
| .323                                | text/h323                               | .906       | application/x-906                   |
| .907                                | drawing/907                             | .a11       | application/x-a11                   |
| .acp                                | audio/x-mei-aac                         | .ai        | application/postscript              |
| .aif                                | audio/aiff                              | .aifc      | audio/aiff                          |
| .aiff                               | audio/aiff                              | .anv       | application/x-anv                   |
| .asa                                | text/asa                                | .asf       | video/x-ms-asf                      |
| .asp                                | text/asp                                | .asx       | video/x-ms-asf                      |
| .au                                 | audio/basic                             | .avi       | video/avi                           |
| .awf                                | application/vnd.adobe.workflow          | .biz       | text/xml                            |
| .bmp                                | application/x-bmp                       | .bot       | application/x-bot                   |
| .c4t                                | application/x-c4t                       | .c90       | application/x-c90                   |
| .cal                                | application/x-cals                      | .cat       | application/vnd.ms-pki.seccat       |
| .cdf                                | application/x-netcdf                    | .cdr       | application/x-cdr                   |
| .cel                                | application/x-cel                       | .cer       | application/x-x509-ca-cert          |
| .cg4                                | application/x-g4                        | .cgm       | application/x-cgm                   |
| .cit                                | application/x-cit                       | .class     | java/*                              |
| .cml                                | text/xml                                | .cmp       | application/x-cmp                   |
| .cmx                                | application/x-cmx                       | .cot       | application/x-cot                   |
| .crl                                | application/pkix-crl                    | .crt       | application/x-x509-ca-cert          |
| .csi                                | application/x-csi                       | .css       | text/css                            |
| .cut                                | application/x-cut                       | .dbf       | application/x-dbf                   |
| .dbm                                | application/x-dbm                       | .dbx       | application/x-dbx                   |
| .dcd                                | text/xml                                | .dcx       | application/x-dcx                   |
| .der                                | application/x-x509-ca-cert              | .dgn       | application/x-dgn                   |
| .dib                                | application/x-dib                       | .dll       | application/x-msdownload            |
| .doc                                | application/msword                      | .dot       | application/msword                  |
| .drw                                | application/x-drw                       | .dtd       | text/xml                            |
| .dwf                                | Model/vnd.dwf                           | .dwf       | application/x-dwf                   |
| .dwg                                | application/x-dwg                       | .dxb       | application/x-dxb                   |
| .dxf                                | application/x-dxf                       | .edn       | application/vnd.adobe.edn           |
| .emf                                | application/x-emf                       | .eml       | message/rfc822                      |
| .ent                                | text/xml                                | .epi       | application/x-epi                   |
| .eps                                | application/x-ps                        | .eps       | application/postscript              |
| .etd                                | application/x-ebx                       | .exe       | application/x-msdownload            |
| .fax                                | image/fax                               | .fdf       | application/vnd.fdf                 |
| .fif                                | application/fractals                    | .fo        | text/xml                            |
| .frm                                | application/x-frm                       | .g4        | application/x-g4                    |
| .gbr                                | application/x-gbr                       | .          | application/x-                      |
| .gif                                | image/gif                               | .gl2       | application/x-gl2                   |
| .gp4                                | application/x-gp4                       | .hgl       | application/x-hgl                   |
| .hmr                                | application/x-hmr                       | .hpg       | application/x-hpgl                  |
| .hpl                                | application/x-hpl                       | .hqx       | application/mac-binhex40            |
| .hrf                                | application/x-hrf                       | .hta       | application/hta                     |
| .htc                                | text/x-component                        | .htm       | text/html                           |
| .html                               | text/html                               | .htt       | text/webviewhtml                    |
| .htx                                | text/html                               | .icb       | application/x-icb                   |
| .ico                                | image/x-icon                            | .ico       | application/x-ico                   |
| .iff                                | application/x-iff                       | .ig4       | application/x-g4                    |
| .igs                                | application/x-igs                       | .iii       | application/x-iphone                |
| .img                                | application/x-img                       | .ins       | application/x-internet-signup       |
| .isp                                | application/x-internet-signup           | .IVF       | video/x-ivf                         |
| .java                               | java/*                                  | .jfif      | image/jpeg                          |
| .jpe                                | image/jpeg                              | .jpe       | application/x-jpe                   |
| .jpeg                               | image/jpeg                              | .jpg       | image/jpeg                          |
| .jpg                                | application/x-jpg                       | .js        | application/x-javascript            |
| .jsp                                | text/html                               | .la1       | audio/x-liquid-file                 |
| .lar                                | application/x-laplayer-reg              | .latex     | application/x-latex                 |
| .lavs                               | audio/x-liquid-secure                   | .lbm       | application/x-lbm                   |
| .lmsff                              | audio/x-la-lms                          | .ls        | application/x-javascript            |
| .ltr                                | application/x-ltr                       | .m1v       | video/x-mpeg                        |
| .m2v                                | video/x-mpeg                            | .m3u       | audio/mpegurl                       |
| .m4e                                | video/mpeg4                             | .mac       | application/x-mac                   |
| .man                                | application/x-troff-man                 | .math      | text/xml                            |
| .mdb                                | application/msaccess                    | .mdb       | application/x-mdb                   |
| .mfp                                | application/x-shockwave-flash           | .mht       | message/rfc822                      |
| .mhtml                              | message/rfc822                          | .mi        | application/x-mi                    |
| .mid                                | audio/mid                               | .midi      | audio/mid                           |
| .mil                                | application/x-mil                       | .mml       | text/xml                            |
| .mnd                                | audio/x-musicnet-download               | .mns       | audio/x-musicnet-stream             |
| .mocha                              | application/x-javascript                | .movie     | video/x-sgi-movie                   |
| .mp1                                | audio/mp1                               | .mp2       | audio/mp2                           |
| .mp2v                               | video/mpeg                              | .mp3       | audio/mp3                           |
| .mp4                                | video/mpeg4                             | .mpa       | video/x-mpg                         |
| .mpd                                | application/vnd.ms-project              | .mpe       | video/x-mpeg                        |
| .mpeg                               | video/mpg                               | .mpg       | video/mpg                           |
| .mpga                               | audio/rn-mpeg                           | .mpp       | application/vnd.ms-project          |
| .mps                                | video/x-mpeg                            | .mpt       | application/vnd.ms-project          |
| .mpv                                | video/mpg                               | .mpv2      | video/mpeg                          |
| .mpw                                | application/vnd.ms-project              | .mpx       | application/vnd.ms-project          |
| .mtx                                | text/xml                                | .mxp       | application/x-mmxp                  |
| .net                                | image/pnetvue                           | .nrf       | application/x-nrf                   |
| .nws                                | message/rfc822                          | .odc       | text/x-ms-odc                       |
| .out                                | application/x-out                       | .p10       | application/pkcs10                  |
| .p12                                | application/x-pkcs12                    | .p7b       | application/x-pkcs7-certificates    |
| .p7c                                | application/pkcs7-mime                  | .p7m       | application/pkcs7-mime              |
| .p7r                                | application/x-pkcs7-certreqresp         | .p7s       | application/pkcs7-signature         |
| .pc5                                | application/x-pc5                       | .pci       | application/x-pci                   |
| .pcl                                | application/x-pcl                       | .pcx       | application/x-pcx                   |
| .pdf                                | application/pdf                         | .pdf       | application/pdf                     |
| .pdx                                | application/vnd.adobe.pdx               | .pfx       | application/x-pkcs12                |
| .pgl                                | application/x-pgl                       | .pic       | application/x-pic                   |
| .pko                                | application/vnd.ms-pki.pko              | .pl        | application/x-perl                  |
| .plg                                | text/html                               | .pls       | audio/scpls                         |
| .plt                                | application/x-plt                       | .png       | image/png                           |
| .png                                | application/x-png                       | .pot       | application/vnd.ms-powerpoint       |
| .ppa                                | application/vnd.ms-powerpoint           | .ppm       | application/x-ppm                   |
| .pps                                | application/vnd.ms-powerpoint           | .ppt       | application/vnd.ms-powerpoint       |
| .ppt                                | application/x-ppt                       | .pr        | application/x-pr                    |
| .prf                                | application/pics-rules                  | .prn       | application/x-prn                   |
| .prt                                | application/x-prt                       | .ps        | application/x-ps                    |
| .ps                                 | application/postscript                  | .ptn       | application/x-ptn                   |
| .pwz                                | application/vnd.ms-powerpoint           | .r3t       | text/vnd.rn-realtext3d              |
| .ra                                 | audio/vnd.rn-realaudio                  | .ram       | audio/x-pn-realaudio                |
| .ras                                | application/x-ras                       | .rat       | application/rat-file                |
| .rdf                                | text/xml                                | .rec       | application/vnd.rn-recording        |
| .red                                | application/x-red                       | .rgb       | application/x-rgb                   |
| .rjs                                | application/vnd.rn-realsystem-rjs       | .rjt       | application/vnd.rn-realsystem-rjt   |
| .rlc                                | application/x-rlc                       | .rle       | application/x-rle                   |
| .rm                                 | application/vnd.rn-realmedia            | .rmf       | application/vnd.adobe.rmf           |
| .rmi                                | audio/mid                               | .rmj       | application/vnd.rn-realsystem-rmj   |
| .rmm                                | audio/x-pn-realaudio                    | .rmp       | application/vnd.rn-rn_music_package |
| .rms                                | application/vnd.rn-realmedia-secure     | .rmvb      | application/vnd.rn-realmedia-vbr    |
| .rmx                                | application/vnd.rn-realsystem-rmx       | .rnx       | application/vnd.rn-realplayer       |
| .rp                                 | image/vnd.rn-realpix                    | .rpm       | audio/x-pn-realaudio-plugin         |
| .rsml                               | application/vnd.rn-rsml                 | .rt        | text/vnd.rn-realtext                |
| .rtf                                | application/msword                      | .rtf       | application/x-rtf                   |
| .rv                                 | video/vnd.rn-realvideo                  | .sam       | application/x-sam                   |
| .sat                                | application/x-sat                       | .sdp       | application/sdp                     |
| .sdw                                | application/x-sdw                       | .sit       | application/x-stuffit               |
| .slb                                | application/x-slb                       | .sld       | application/x-sld                   |
| .slk                                | drawing/x-slk                           | .smi       | application/smil                    |
| .smil                               | application/smil                        | .smk       | application/x-smk                   |
| .snd                                | audio/basic                             | .sol       | text/plain                          |
| .sor                                | text/plain                              | .spc       | application/x-pkcs7-certificates    |
| .spl                                | application/futuresplash                | .spp       | text/xml                            |
| .ssm                                | application/streamingmedia              | .sst       | application/vnd.ms-pki.certstore    |
| .stl                                | application/vnd.ms-pki.stl              | .stm       | text/html                           |
| .sty                                | application/x-sty                       | .svg       | text/xml                            |
| .swf                                | application/x-shockwave-flash           | .tdf       | application/x-tdf                   |
| .tg4                                | application/x-tg4                       | .tga       | application/x-tga                   |
| .tif                                | image/tiff                              | .tif       | application/x-tif                   |
| .tiff                               | image/tiff                              | .tld       | text/xml                            |
| .top                                | drawing/x-top                           | .torrent   | application/x-bittorrent            |
| .tsd                                | text/xml                                | .txt       | text/plain                          |
| .uin                                | application/x-icq                       | .uls       | text/iuls                           |
| .vcf                                | text/x-vcard                            | .vda       | application/x-vda                   |
| .vdx                                | application/vnd.visio                   | .vml       | text/xml                            |
| .vpg                                | application/x-vpeg005                   | .vsd       | application/vnd.visio               |
| .vsd                                | application/x-vsd                       | .vss       | application/vnd.visio               |
| .vst                                | application/vnd.visio                   | .vst       | application/x-vst                   |
| .vsw                                | application/vnd.visio                   | .vsx       | application/vnd.visio               |
| .vtx                                | application/vnd.visio                   | .vxml      | text/xml                            |
| .wav                                | audio/wav                               | .wax       | audio/x-ms-wax                      |
| .wb1                                | application/x-wb1                       | .wb2       | application/x-wb2                   |
| .wb3                                | application/x-wb3                       | .wbmp      | image/vnd.wap.wbmp                  |
| .wiz                                | application/msword                      | .wk3       | application/x-wk3                   |
| .wk4                                | application/x-wk4                       | .wkq       | application/x-wkq                   |
| .wks                                | application/x-wks                       | .wm        | video/x-ms-wm                       |
| .wma                                | audio/x-ms-wma                          | .wmd       | application/x-ms-wmd                |
| .wmf                                | application/x-wmf                       | .wml       | text/vnd.wap.wml                    |
| .wmv                                | video/x-ms-wmv                          | .wmx       | video/x-ms-wmx                      |
| .wmz                                | application/x-ms-wmz                    | .wp6       | application/x-wp6                   |
| .wpd                                | application/x-wpd                       | .wpg       | application/x-wpg                   |
| .wpl                                | application/vnd.ms-wpl                  | .wq1       | application/x-wq1                   |
| .wr1                                | application/x-wr1                       | .wri       | application/x-wri                   |
| .wrk                                | application/x-wrk                       | .ws        | application/x-ws                    |
| .ws2                                | application/x-ws                        | .wsc       | text/scriptlet                      |
| .wsdl                               | text/xml                                | .wvx       | video/x-ms-wvx                      |
| .xdp                                | application/vnd.adobe.xdp               | .xdr       | text/xml                            |
| .xfd                                | application/vnd.adobe.xfd               | .xfdf      | application/vnd.adobe.xfdf          |
| .xhtml                              | text/html                               | .xls       | application/vnd.ms-excel            |
| .xls                                | application/x-xls                       | .xlw       | application/x-xlw                   |
| .xml                                | text/xml                                | .xpl       | audio/scpls                         |
| .xq                                 | text/xml                                | .xql       | text/xml                            |
| .xquery                             | text/xml                                | .xsd       | text/xml                            |
| .xsl                                | text/xml                                | .xslt      | text/xml                            |
| .xwd                                | application/x-xwd                       | .x_b       | application/x-x_b                   |
| .sis                                | application/vnd.symbian.install         | .sisx      | application/vnd.symbian.install     |
| .x_t                                | application/x-x_t                       | .ipa       | application/vnd.iphone              |
| .apk                                | application/vnd.android.package-archive | .xap       | application/x-silverlight-app       |



## ASCLL对照表

| ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 |
| :------ | :------- | :------ | :------- | :------ | :------- | :------ | :------- |
| 0       | NUT      | 32      | (space)  | 64      | @        | 96      | 、       |
| 1       | SOH      | 33      | !        | 65      | A        | 97      | a        |
| 2       | STX      | 34      | "        | 66      | B        | 98      | b        |
| 3       | ETX      | 35      | #        | 67      | C        | 99      | c        |
| 4       | EOT      | 36      | $        | 68      | D        | 100     | d        |
| 5       | ENQ      | 37      | %        | 69      | E        | 101     | e        |
| 6       | ACK      | 38      | &        | 70      | F        | 102     | f        |
| 7       | BEL      | 39      | ,        | 71      | G        | 103     | g        |
| 8       | BS       | 40      | (        | 72      | H        | 104     | h        |
| 9       | HT       | 41      | )        | 73      | I        | 105     | i        |
| 10      | LF       | 42      | *        | 74      | J        | 106     | j        |
| 11      | VT       | 43      | +        | 75      | K        | 107     | k        |
| 12      | FF       | 44      | ,        | 76      | L        | 108     | l        |
| 13      | CR       | 45      | -        | 77      | M        | 109     | m        |
| 14      | SO       | 46      | .        | 78      | N        | 110     | n        |
| 15      | SI       | 47      | /        | 79      | O        | 111     | o        |
| 16      | DLE      | 48      | 0        | 80      | P        | 112     | p        |
| 17      | DCI      | 49      | 1        | 81      | Q        | 113     | q        |
| 18      | DC2      | 50      | 2        | 82      | R        | 114     | r        |
| 19      | DC3      | 51      | 3        | 83      | S        | 115     | s        |
| 20      | DC4      | 52      | 4        | 84      | T        | 116     | t        |
| 21      | NAK      | 53      | 5        | 85      | U        | 117     | u        |
| 22      | SYN      | 54      | 6        | 86      | V        | 118     | v        |
| 23      | TB       | 55      | 7        | 87      | W        | 119     | w        |
| 24      | CAN      | 56      | 8        | 88      | X        | 120     | x        |
| 25      | EM       | 57      | 9        | 89      | Y        | 121     | y        |
| 26      | SUB      | 58      | :        | 90      | Z        | 122     | z        |
| 27      | ESC      | 59      | ;        | 91      | [        | 123     | {        |
| 28      | FS       | 60      | <        | 92      | /        | 124     | \|       |
| 29      | GS       | 61      | =        | 93      | ]        | 125     | }        |
| 30      | RS       | 62      | >        | 94      | ^        | 126     | `        |
| 31      | US       | 63      | ?        | 95      | _        | 127     | DEL      |



## 错误状态码对照表

| 状态码 | 含义                                                         |
| :----- | :----------------------------------------------------------- |
| 100    | 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 |
| 101    | 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 |
| 102    | 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。     |
| 200    | 请求已成功，请求所希望的响应头或数据体将随此响应返回。       |
| 201    | 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。 |
| 202    | 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 |
| 203    | 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 |
| 204    | 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 |
| 205    | 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 |
| 206    | 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 |
| 207    | 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 |
| 300    | 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 |
| 301    | 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 |
| 302    | 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 |
| 303    | 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 |
| 304    | 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 |
| 305    | 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 |
| 306    | 在最新版的规范中，306状态码已经不再被使用。                  |
| 307    | 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 |
| 400    | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。 |
| 401    | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 |
| 402    | 该状态码是为了将来可能的需求而预留的。                       |
| 403    | 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 |
| 404    | 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 |
| 405    | 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 |
| 406    | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 |
| 407    | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 |
| 408    | 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 |
| 409    | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 |
| 410    | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 |
| 411    | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 |
| 412    | 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 |
| 413    | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 |
| 414    | 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 |
| 415    | 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 |
| 416    | 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 |
| 417    | 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 |
| 421    | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 |
| 422    | 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 |
| 422    | 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV） |
| 424    | 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） |
| 425    | 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 |
| 426    | 客户端应当切换到TLS/1.0。（RFC 2817）                        |
| 449    | 由微软扩展，代表请求应当在执行完适当的操作后进行重试。       |
| 500    | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 |
| 501    | 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 |
| 502    | 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 |
| 503    | 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 |
| 504    | 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误 |
| 505    | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 |
| 506    | 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 |
| 507    | 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) |
| 509    | 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 |
| 510    | 获取资源所需要的策略并没有没满足。（RFC 2774）               |



# HTML5

## 基础知识

# CSS3

## 基础知识

## 案例收集

### 旋转的太极

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            background-color: #adadad;/*设置背景色*/
        }

        #yinyang {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(/*圆球上半部分为白色，下半部分为黑色*/
                    to bottom,
                    #ffffff 0%,
                    #ffffff 50%,
                    #000000 50%,
                    #000000 100%
            );
            position: relative;
            margin: 100px auto;
            animation:rotation 2.5s linear infinite;-webkit-animation:rotation 2.5s linear infinite;-moz-animation:rotation 2.5s linear infinite;
        }

        #yinyang::before {
            position: absolute;
            content: "";
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 40px solid black;/*左侧黑球套白点*/
            background-color: white;
            left: 0;
            top: 50px;
        }

        #yinyang::after {
            position: absolute;
            content: "";
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 40px solid white;/*右侧白球套黑点*/
            background-color: black;
            right: 0;
            top: 50px;
        }
        @keyframes rotation {
            0% {transform:rotate(0deg);}
            100% {transform:rotate(360deg);}
        }
        @-webkit-keyframes rotation {
            0% {-webkit-transform:rotate(0deg);}
            100% {-webkit-transform:rotate(360deg);}
        }
        @-moz-keyframes rotation {
            0% {-moz-transform:rotate(0deg);}
            100% {-moz-transform:rotate(360deg);}
        }
    </style>
</head>
<body>
    <div id="yinyang"></div>
</body>
</html>
~~~



# JS++

## 基础

### 质数案例

~~~js
let c = 0
for (let i = 2; i < 100; i++){
  for (let j = 0; j <= i; j++){
    if (i % j === 0) {
      c++
    }
  }
  if (c === 2){
    console.log(i)
  }
  c = 0
}
~~~

### 阶乘案例

~~~js
function fact(n) {
  if (n === 1) return 1
  return n * fact(--n)
}
console.log(fact(5))
~~~

### 预编译

~~~js
function test(a) {
  console.log(a)
  var a = 1
  console.log(a)
  function a() {}
  console.log(a)
  var b = function () {}
  console.log(b)
  function d() {}
}
test(2)
//函数声明整体提升,变量只有声明提升,赋值不提升
//AO activation object
/*
1.寻找形参和变量声明
2.实参值赋值给形参
3.找函数声明,赋值
4.执行
 */
console.log(a,b)
function a() {}
var b = function () {}
//GO global object
/*
1.找变量
2.找函数声明
3.执行
 */
~~~

### 立即执行函数

~~~js
//()包裹会将里面的函数转换为表达式
(function test() {
  console.log(123)
})()
//或者
(function test() {
  console.log(123)
}())
//声明式函数使用立即执行会报语法错误
function test() {
  console.log(123)
}()
//表达式忽略函数名
//用()包裹函数会将函数转换为函数表达式
(function b (){})
console.log(b)
//()会将函数转换为函数表达式,所以b不存在会报错
//因为用了typeof所以会返回undefined
var a = 10
if (function b() {}) {
  a += typeof(b)
}
console.log(a)
//函数表达式可以使用立即执行符号
//立即执行函数,执行后立即销毁,test为undefined
let test = function (){
  console.log(2)
}()
console.log(test)
~~~

### 闭包

~~~js
//闭包: i最后的值为10,因内部函数仍然访问着i,故i不会被销毁,
//内部函数在循环内未被执行,循环完成后内部函数访问的就是i最后的值
//可以在循环内使用let声明i,let每次声明会创建块级作用域,每次循环的i都独立存在
function test() {
  var arr = []
  for (var i = 0; i < 10; i++){
    arr[i] = function () {
      console.log(i)
    }
  }
  return arr
}
var myArr = test()
for (var j = 0; j < 10; j++){
  myArr[j]()
}
//使用立即执行函数包裹循环内部的函数表达式并将i传进去
function test() {
  var arr = []
  for (var i = 0; i < 10; i++){
    (function (i) {
      arr[i] = function () {
        console.log(i)
      }
    })(i)
  }
  return arr
}
var myArr = test()
for (var j = 0; j < 10; j++){
  myArr[j]()
}
~~~



### 深浅拷贝

~~~js
//浅拷贝
function clone(origin, target){
  let tar = target || {}
  for (let key in origin){
    if (origin.hasOwnProperty(key)){
      tar[key] = origin[key]
    }
  }
  return tar
}
//深拷贝
function deepClone(origin, target) {
  let tar = target || {},
    toStr = Object.prototype.toString,
    arrType = '[object Array]';
  for (let key in origin){
    if (origin.hasOwnProperty(key)){
      if (typeof(origin[key]) === 'object' && origin[key] !== null){
        if (toStr.call(origin[key]) === arrType){
          tar[key] = []
        }else {
          tar[key] = {}
        }
        deepClone(origin[key], tar[key])
      }else {
        tar[key] = origin[key]
      }
    }
  }
  return tar
}
~~~



### 构造函数与原型

~~~js
//getName5函数提升,运行时赋值为getName4,Foo()执行getName1赋值到全局覆盖了getName4
//点运算符优先于new,第一次new无效
//new Foo()为整体优先执行,因自身没有getName会寻找原型上的getName3
//最后的new同理先执行new Foo().getName(),开头的new无效.
function Foo() {
  getName = function (){
    console.log(1)
  }
  return this
}
Foo.getName = function () {
  console.log(2)
}
Foo.prototype.getName = function () {
  console.log(3)
}
var getName = function () {
  console.log(4)
}
function getName() {
  console.log(5)
}
Foo.getName(); 	//2
getName()		//4
Foo().getName()	//1
getName()		//1
new Foo.getName()	//2
new Foo().getName()	//3
new new Foo().getName()	//3
~~~



### 完善typeof方法

```js
function myTypeof(val) {
  if (val === null) return 'null'
  let type = typeof(val)
  let toStr = Object.prototype.toString
  return type === 'object' ? {
    '[object Array]': 'array',
    '[object Object]': 'object',
    '[object Number]': 'object number',
    '[object String]': 'object string',
    '[object Boolean]': 'object boolean'
  }[toStr.call(val)] : type
}
console.log(myTypeof({}))
```



## BOM

~~~js
//临时窗口的开启与关闭
win = window.open('http://www.baidu.com', 'cwin', 'width=500, height=500, top=200, left=300', false)
win.close()
~~~



### window.navigator

脚本:

~~~js
function checkBrowser(){
	var nVer = navigator.appVersion,
      nAgt = navigator.userAgent,
      browser = navigator.appName,
      version = '' + parseFloat(navigator.appVersion),
      majorVersion, 
      nameOffset, 
      verOffset, 
      ix, 
      network = 'unknown';
      
  // Opera浏览器（老版本）
  if ((verOffset = nAgt.indexOf('Opera')) != -1) {
      browser = 'Opera';
      version = nAgt.substring(verOffset + 6);
      if ((verOffset = nAgt.indexOf('Version')) != -1) {
          version = nAgt.substring(verOffset + 8);
      }
  }
  // Opera浏览器（新版本）
  if ((verOffset = nAgt.indexOf('OPR')) != -1) {
      browser = 'Opera';
      version = nAgt.substring(verOffset + 4);
  }
  // IE浏览器
  else if ((verOffset = nAgt.indexOf('MSIE')) != -1) {
      browser = 'Microsoft Internet Explorer';
      version = nAgt.substring(verOffset + 5);
  }
  // Chrome浏览器
  else if ((verOffset = nAgt.indexOf('Chrome')) != -1) {
      browser = 'Chrome';
      version = nAgt.substring(verOffset + 7);
  }
  // Safari浏览器
  else if ((verOffset = nAgt.indexOf('Safari')) != -1) {
      browser = 'Safari';
      version = nAgt.substring(verOffset + 7);
      if ((verOffset = nAgt.indexOf('Version')) != -1) {
          version = nAgt.substring(verOffset + 8);
      }
  }
// Firefox浏览器
  else if ((verOffset = nAgt.indexOf('Firefox')) != -1) {
      browser = 'Firefox';
      version = nAgt.substring(verOffset + 8);
  }
// IE11+浏览器
  else if (nAgt.indexOf('Trident/') != -1) {
      browser = 'Microsoft Internet Explorer';
      version = nAgt.substring(nAgt.indexOf('rv:') + 3);
  }
// 微信浏览器
  else if (nAgt.indexOf('NetType/') != -1) {
      browser = 'WeiXin';
      if (nAgt.indexOf('NetType/WIFI') != -1) {
          network = 'WIFI';
      }else if(nAgt.indexOf('NetType/2G') != -1) {
          network = '2G';
      }else if(nAgt.indexOf('NetType/3G+') != -1) {
          network = '3G+';
      }
      verOffset = nAgt.lastIndexOf('/')
      version = nAgt.substring(verOffset + 1);
      if (browser.toLowerCase() == browser.toUpperCase()) {
          browser = navigator.appName;
      }
  }
  //其他浏览器
  else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
      browser = nAgt.substring(nameOffset, verOffset);
      version = nAgt.substring(verOffset + 1);
      if (browser.toLowerCase() == browser.toUpperCase()) {
          browser = navigator.appName;
      }
  }

  //版本字符串整理
  if ((ix = version.indexOf(';')) != -1) version = version.substring(0, ix);
  if ((ix = version.indexOf(' ')) != -1) version = version.substring(0, ix);
  if ((ix = version.indexOf(')')) != -1) version = version.substring(0, ix);
  majorVersion = parseInt('' + version, 10);
  if (isNaN(majorVersion)) {
      version = '' + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
  }

  //移动版本
  var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);

  //系统探测
  var os = '';
  var clientStrings = [
      {s: 'Windows 10', r: /(Windows 10.0|Windows NT 10.0)/},
      {s: 'Windows 8.1', r: /(Windows 8.1|Windows NT 6.3)/},
      {s: 'Windows 8', r: /(Windows 8|Windows NT 6.2)/},
      {s: 'Windows 7', r: /(Windows 7|Windows NT 6.1)/},
      {s: 'Windows Vista', r: /Windows NT 6.0/},
      {s: 'Windows Server 2003', r: /Windows NT 5.2/},
      {s: 'Windows XP', r: /(Windows NT 5.1|Windows XP)/},
      {s: 'Windows 2000', r: /(Windows NT 5.0|Windows 2000)/},
      {s: 'Windows ME', r: /(Win 9x 4.90|Windows ME)/},
      {s: 'Windows 98', r: /(Windows 98|Win98)/},
      {s: 'Windows 95', r: /(Windows 95|Win95|Windows_95)/},
      {s: 'Windows NT 4.0', r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},
      {s: 'Windows CE', r: /Windows CE/},
      {s: 'Windows 3.11', r: /Win16/},
      {s: 'Android', r: /Android/},
      {s: 'Open BSD', r: /OpenBSD/},
      {s: 'Sun OS', r: /SunOS/},
      {s: 'Linux', r: /(Linux|X11)/},
      {s: 'iOS', r: /(iPhone|iPad|iPod)/},
      {s: 'Mac OS X', r: /Mac OS X/},
      {s: 'Mac OS', r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/},
      {s: 'QNX', r: /QNX/},
      {s: 'UNIX', r: /UNIX/},
      {s: 'BeOS', r: /BeOS/},
      {s: 'OS/2', r: /OS\/2/},
      {s: 'Search Bot', r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/}
  ];
  for (var id in clientStrings) {
      var cs = clientStrings[id];
      if (cs.r.test(nAgt)) {
          os = cs.s;
          break;
      }
  }
  var osVersion = '';
  if (/Windows/.test(os)) {
      osVersion = /Windows (.*)/.exec(os)[1];
      os = 'Windows';
  }
  switch (os) {
      case 'Mac OS X':
          osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
          break;
      case 'Android':
          osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
          break;
      case 'iOS':
          osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
          osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
          break;
  }

  //返回数据集合
  return {
  	//操作系统
	  os: os,
	  //操作系统版本
	  osVersion: osVersion ? osVersion : 'unknown',
	  //是否移动端访问
	  mobile: mobile,
	  //浏览器类型
	  browser: browser,
	  //浏览器版本
	  browserVersion: version,
	  //浏览器major版本
	  browserMajorVersion: majorVersion
  };
  
}
~~~



### window.screen

~~~js
window.screen.orientation.type = "portrait-primary"		//竖屏
window.screen.orientation.type = "landscape-primary"	//横屏
~~~



### window.location

~~~js
protocol//协议
hostname//主机名 域名
port	//端口
pathname//路径
search	//参数
hash	//哈希值
href	//整个url
~~~





## 数组扩展

### sort

~~~js
//按字节数排序
function getBytes(str) {
  let bytes = str.length
  for (let i = 0; i < str.length; i++){
    if (str.charCodeAt(i) > 255){
      bytes++
    }
  }
  return bytes
}
let arr = ['123', '高江华', '灰太狼', 'hello']
arr.sort(function (a, b) {
  return getBytes(a) - getBytes(b)
})
console.log(arr)

~~~





### unshift

~~~js
let arr = ['a', 'b', 'c']
//方法一
Array.prototype.myUnshift1 = function () {
  let pos = 0
  for(let i = 0; i < arguments.length; i++){
    this.splice(pos, 0, arguments[i])
    pos++
  }
  return this.length
}
let array1 = arr.myUnshift1('d')
console.log(arr)
//方法二
Array.prototype.myUnshift2 = function () {
  let argArr = Array.from(arguments)
  return argArr.concat(this)
}
let array2 = arr.myUnshift2('e')
console.log(array2)
~~~





### push

~~~js
//手写push
Array.prototype.myPush = function () {
  for (let i = 0; i < arguments.length; i++){
    this[this.length] = arguments[i]
  }
  return this.length
}
~~~





### forEach

~~~js
//function(value, index, array)-->必填函数
//第二参数可以自定义内部this指向, 类型原始值指向类型对象
[1,2,3,4,5].forEach(function (value, index, array) {
  console.log(this)
}, {name: 'test'})
//手写forEach
Array.prototype.myForEach = function (fn) {
  let arr = this,
    len = arr.length,
    arg2 = arguments[1] || window
  for (let i = 0; i < len; i++){
    fn.apply(arg2, [arr[i], i, arr])
  }
}
~~~

### filter

~~~js
//function(value, index, array)-->必填函数
//返回一个新数组,若为true返回符合条件的数据的数组,反之返回空数组
//第二参数可以自定义内部this指向, 类型原始值指向类型对象
//内部修改数据,引用的原数组,会进行深拷贝,会改变原数组
let data = [
  {
    course: '123'
  },
  {
    course: '456'
  }
]
let Arr = data.filter(function (value, index, array) {
  value.course = this.name + value.course
  return index === 0;
}, {name: '123'})
console.log(Arr)
console.log(data)
//手写解决深拷贝问题
function deepClone(org, tar){
  tar = tar || {}
  let tostr = Object.prototype.toString,
    arrType = '[object Array]'
  for (let key in org){
   if (org.hasOwnProperty(key)){
     if (typeof(org[key]) === 'object' && org[key] !== null){
       tar[key] = tostr.call(org[key]) === arrType ? [] : {}
       deepClone(org[key], tar[key])
     }else {
       tar[key] = org[key]
     }
   }
  }
  return tar
}
Array.prototype.myFilter = function (fn) {
  let arr = this,
    len = arr.length,
    arg2 = arguments[1] || window,
    Arr = [],
    Item
  for (let i = 0; i < len; i++){
    Item = deepClone(arr[i], {})
    fn.apply(arg2, [Item, i, arr]) ? Arr.push(Item) : ''
  }
  return Arr
}
let Arr1 = data.myFilter(function (value, index, array) {
  value.course = this.name + value.course
  return index === 0;
}, {name: '123'})
console.log(Arr1)
console.log(data)
~~~



### map

~~~js
//function(value, index, array)-->必填函数
//返回一个新数组,包含遍历的每一项
//第二参数可以自定义内部this指向, 类型原始值指向类型对象
//内部修改数据,引用的原数组,会进行深拷贝,会改变原数组
let data = [
  {
    course: '123'
  },
  {
    course: '456'
  }
]
let Arr1 = data.map(function (value, index, array) {
  value.course = this.name + value.course
  return value
}, {name: '123'})
console.log(Arr1)
console.log(data)
//手写
function deepClone(org, tar){
  tar = tar || {}
  let tostr = Object.prototype.toString,
    arrType = '[object Array]'
  for (let key in org){
    if (org.hasOwnProperty(key)){
      if (typeof(org[key]) === 'object' && org[key] !== null){
        tar[key] = tostr.call(org[key]) === arrType ? [] : {}
        deepClone(org[key], tar[key])
      }else {
        tar[key] = org[key]
      }
    }
  }
  return tar
}
Array.prototype.myMap = function (fn) {
  let arr = this,
    len = arr.length,
    arg2 = arguments[1] || window,
    Arr = [],
    Item
  for (let i = 0; i < len; i++){
    Item = deepClone(arr[i], {})
    Arr.push(fn.apply(arg2, [Item, i, arr]))
  }
  return Arr
}
let Arr2 = data.myMap(function (value, index, array) {
  value.course = this.name + value.course
  return value;
}, {name: '123'})
console.log(Arr2)
console.log(data)

~~~



### every

~~~js
//function(value, index, array)-->必填函数
//返回boolean类型,若每一项都符合条件则返回true
//若有一项不符合条件则返回false并结束循环
//第二参数可以自定义内部this指向, 类型原始值指向类型对象
//内部修改数据,引用的原数组,会改变原数组
let data = [
  {
    course: '123'
  },
  {
    course: '456'
  },
  {
    course: '123'
  }
]
let Arr1 = data.every(function (value, index, array) {
  console.log(1)
  value.course = this.name + value.course
  return value.course === '123123'
}, {name: '123'})
console.log(Arr1)
//手写
Array.prototype.myEvery = function (fn) {
  let arr = this,
    len = arr.length,
    arg2 = arguments[1] || window,
    res = true
  for (let i = 0; i < len; i++){
    if (!fn.apply(arg2, [arr[i], i, arr])){
      res = false
      break
    }
  }
  return res
}
~~~



### some

~~~js
//function(value, index, array)-->必填函数
//返回boolean类型,若有一项符合条件就返回true并结束循环
//若全都不符合条件则返回false
//第二参数可以自定义内部this指向, 类型原始值指向类型对象
//内部修改数据,引用的原数组,会改变原数组
let data = [
  {
    course: '123'
  },
  {
    course: '456'
  },
  {
    course: '123'
  }
]
let Arr1 = data.some(function (value, index, array) {
  console.log(1)
  value.course = this.name + value.course
  return value.course === '123123'
}, {name: '123'})
console.log(Arr1)
//手写
Array.prototype.myEvery = function (fn) {
  let arr = this,
    len = arr.length,
    arg2 = arguments[1] || window,
    res = false
  for (let i = 0; i < len; i++){
    if (fn.apply(arg2, [arr[i], i, arr])){
      res = true
      break
    }
  }
  return res
}
~~~



### reduce

~~~js
//function(prev, cur, index, array)-->必填函数
//计算数组元素相加后的总和,首次循环prev为数组的第一项,cur为后一项
//后续循环prev为两项相加之和,cur为后移的一项
//可指定reduce的第二个参数,那么prev则引用它,若内部不做加工则只会遍历一次,后面都是undefined
//内部操作不会改变原数组
let data = [
  123,456,789
]
let Arr1 = data.reduce(function (prev, cur, index, array) {
  console.log(prev, this)
  prev.name += 1
  return prev
}, {name: '123'})
console.log(Arr1)
//手写
Array.prototype.myReduce = function (fn, value) {
  let arr = this,
    len = arr.length,
    arg3 = arguments[2] || window
  for (let i = 0; i < len; i++){
    value = fn.apply(arg3, [value, arr[i], i, arr])
  }
  return value
}
~~~



### reduceRight

~~~js
//function(prev, cur, index, array)-->必填函数
//计算数组元素相加后的总和,首次循环prev为数组的最后一项,cur为prev的前一项
//后续循环prev为两项相加之和,cur为前移的一项
//可指定reduce的第二个参数,那么prev则引用它,若内部不做加工则只会遍历一次,后面都是undefined
//内部操作不会改变原数组
let data = [
  123,456,789
]
let Arr1 = data.reduceRight(function (prev, cur, index, array) {
  console.log(prev, cur)
  return prev + cur
})
console.log(Arr1)
console.log(data)
//手写
Array.prototype.myReduceRight = function (fn, value) {
  let arr = this,
    len = arr.length,
    arg3 = arguments[2] || window
  for (let i = len - 1; i < 0; i--){
    value = fn.apply(arg3, [value, arr[i], i, arr])
  }
  return value
}
~~~



### 数组去重

~~~js
let arr = [0,0,1,1,2,3,5,4,8,6,5,4,2,3,5]
Array.prototype.unique = function () {
  let temp = {},
    newArr = []
  for (let i = 0; i < this.length; i++){
    if (!temp.hasOwnProperty(this[i])){
      temp[this[i]] = this[i]
      newArr.push(this[i])
    }
  }
  return newArr
}
console.log(arr.unique())
~~~





### 面试题

~~~js
// Array.prototype.push = function (el) {
//   this[this.length] = el
//   this.length ++
// }
//obj.2 = 1
//obj.3 = 2
//obj.length = 4
let obj = {
  '2': 3,
  '3': 4,
  'length': 2,
  'splice': Array.prototype.splice,
  'push': Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
~~~

~~~js
//找出第一个不重复的字母
let arr = 'truattsdoewlemnweopkjklhdnf'
function test(str) {
  let obj = {}
  for (let i = 0; i < str.length; i++){
    if (obj.hasOwnProperty(str[i])){
      obj[str[i]]++
    }else {
      obj[str[i]] = 1
    }
  }
  for (let key in obj){
    if (obj[key] === 1){
      return key
    }
  }
}
console.log(test(arr))
~~~



## 函数特性

JS编程特点:

- 函数式编程和面向对象编程的混合语言
- 可扩展性强
- 优点: 编程灵活, 易学
- 缺点: 不可控

面向对象编程:

- 复杂的this, 经常使用call apply bind
- 避免不了的点访问会耗费性能
- 优点: 程序的高度复用

函数式编程:

- 概念: 函数是第一类对象, 不依赖任何其他对象独立存在
- 易读, 易维护

纯函数:

- 相同的输入得到相同的输出, 不依赖且不影响外部环境也不产生任何副作用

- 输出完全取决于输入

函数组合: 左倾方式

~~~js
//函数组合->饲养函数->compose
//若干个纯函数, 偏函数, 柯里化函数组合成一个新函数, 形成数据传递, 并实现一种有序执行的效果
function a (str) {
  return str.toUpperCase()
}
function b (str) {
  return str + '!'
}
function compose (a, b) {
  return function (x) {
    return a(b(x))
  }
}
let f = compose(a, b)
console.log(f('hello'))
~~~

封装compose函数

~~~js
function a (str) {
  return str.toUpperCase()
}
function b (str) {
  return str + '!'
}
function c (str) {
  return str.split('')
}
function d (str) {
  return str.reverse()
}
function e (str) {
  return str.join('-')
}
function compose () {
  let args = Array.prototype.slice.call(arguments);
  return function (x) {
    return args.reduceRight(function (prev, cur) {
      return cur(prev)
    }, x)
  }
}
let f = compose(b, e, d, c, a)
console.log(f('hello'))
~~~



### 结合律

结合律 ( Associativity ): 

- 在组合函数的参数中再进行分组组合与原来的分组结果是一样的, 不受影响

~~~js
function a (str) {
  return str.toUpperCase()
}
function b (str) {
  return str + '!'
}
function c (str) {
  return str.split('')
}
function d (str) {
  return str.reverse()
}
function e (str) {
  return str.join('-')
}
function compose () {
  let args = Array.prototype.slice.call(arguments);
  return function (x) {
    return args.reduceRight(function (prev, cur) {
      return cur(prev)
    }, x)
  }
}
let f1 = compose(b, e, d, c, a)
let f2 = compose(b, compose(e, d), c, a)
let f3 = compose(b, compose(e, d, c, a))
console.log(f1('hello'))
console.log(f2('hello'))
console.log(f3('hello'))
//f1 f2 f3 结果一致
~~~



### 函数无值风格

Pointfree style means never having to say your data

( Pointfree风格意味着永远不必说出你的数据 )

~~~js
//组合函数调用时是看到值的即(Pointfree)无值风格
let f3 = compose(b, compose(e, d, c, a))
console.log(f1('hello'))
~~~



### 函数柯里化

目的: 将一个多参数的函数转成多个单参数的函数, 将n元函数转换成n个一元函数

- 简化代码
- 提高维护性
- 功能单一化
- 功能内聚
- 降低耦合
- 降低代码重复性
- 提高代码适应性 

~~~js
function curry (fn, len) {
  len = len || fn.length
  let func = function (fn) {
    let arg = [].slice.call(arguments, 1)
    return function () {
      let args = [...arg, ...[].slice.call(arguments)]
      return fn.apply(this, args)
    }
  }
  return function () {
    let argLen = arguments.length
    if (argLen < len){
      let Arr = [fn, ...[].slice.call(arguments)]
      return curry(func.apply(this, Arr), len - argLen)
    }else {
      return fn.apply(this, arguments)
    }
  }
}
function add (a, b, c, d) {
  return a + b + c + d
}
let num = curry(add)
let res1 = num(1,2)(3,4)
let res2 = num(1)(2,3,4)
let res3 = num(1,2,3)(4)
let res4 = num(1,2,3,4)
console.log(res1)
console.log(res2)
console.log(res3)
console.log(res4)
~~~

ES6写法

~~~js
const add = (a, b, c, d) => {
  return a + b + c + d
}
const curry = (fn, arr = []) => {
  let len = fn.length
  return (...args) => {
    arr = [...arr, ...args]
    if (arr.length < len){
      return curry(fn, arr)
    }
    return fn(...arr)
  }
}
let num = curry(add)(1)(2)(3)(4)
console.log(num)
~~~



### 偏函数

在计算机科学中, 偏函数叫做部分应用, 局部应用

指固定一个函数的一些参数, 然后产生另一个更小元的函数

目的: 固定一个函数的一个或多个参数, 将n元函数转换成n-x元函数

~~~js
function add (a,b,c,d) {
  return a+b+c+d
}
Function.prototype.partial = function () {
  let self = this
  let args = [].slice.call(arguments)
  return function () {
    let newArgs = args.concat([].slice.call(arguments))
    return self.apply(this, newArgs)
  }
}
let num = add.partial(1,2)
console.log(num(3,4))
~~~



### 惰性函数

惰性加载表示函数执行的分支只会在函数第一次调用的时候执行

在第一次调用的过程中, 该函数被覆盖为另一个按照合适的方式执行的函数

这样任何对原函数的调用就不用再经过执行的分支了

~~~js
let getTime = function () {
  let time = new Date().getTime()
  console.log(1)
  getTime = function () {
    console.log(2)
    return time
  }
  return getTime()
}

console.log(getTime())
console.log(getTime())
console.log(getTime())
console.log(getTime())
~~~

举例

~~~js
let test = function (num){
  switch (num) {
    case 1:
      test = function () {
        console.log('我爱你')
      }
      break;
    case 2:
      test = function () {
        console.log('我喜欢你')
      }
      break;
    case 3:
      test = function () {
        console.log('我讨厌你')
      }
  }
  return test();
}
test(3)
~~~



## 函数优化

### 缓存函数

通过缓存池优化递归函数提升性能

~~~~js
//阶乘递归
let time = 0
function a (n) {
  time++
  if (n === 0 || n === 1) {
    return 1
  }
  return n * a(n - 1)
}
//查看实际计算次数
for (let i = 0; i <= 6; i++){
  console.log(a(i))
}
console.log(time)
//通过缓存优化,缺点全局污染
let times = 0
let cache = []
function b (n) {
  times++
  if (cache[n]) return cache[n];
  if (n === 0 || n === 1){
    cache[0] = 1
    cache[1] = 1
    return 1;
  }
  return cache[n] = n * b(n - 1)
}
//通过闭包封装优化
function me (fn) {
  let cache = {}
  return function () {
    let k = arguments.length + [].join.call(arguments, ',')
    return cache[k] = cache[k] || fn.apply(this, arguments)
  }
}
let f = me(a)
//查看实际计算次数
for (let i = 0; i <= 6; i++){
  console.log(b(i))
}
console.log(times)
//递归性能用时
console.time('start')
console.log(a(6))
console.timeEnd('start')
//优化后的性能用时
console.time('start1')
console.log(f(6))
console.timeEnd('start1')
~~~~



### 函数防抖

n秒内只要你触发事件, 就重新计时,事件处理函数的程序将永远不能被执行

n秒外就会执行事件处理函数

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            width: 200px;
            height: 200px;
            background-color: red;
        }
        input {
            width: 80px;
            height: 30px;
        }
        #btn{
            width: 50px;
            height: 30px;
        }
    </style>
</head>
<body>
<button id="btn">按钮</button>
<input id="input" type="text">
<script>
  //防抖封装函数
  function debounce (fn, time, triggle) {
    let t = null
    let debounced = function () {
      let _self = this
      args = arguments
      if (t){
        clearTimeout(t)
      }
      if (triggle){
        let exec = !t
        t = setTimeout(function () {
          t = null
        }, time)
        if (exec){
          fn.apply(_self, args)
        }
      }else {
        t = setTimeout(function () {
          fn.apply(_self, args)
        }, time)
      }
    }
    debounced.remove = function () {
      clearTimeout(t)
      t = null
    }
    return debounced
  }
  //按钮防抖
  let oBtn = document.getElementById('btn')
  oBtn.onclick = debounce(btnClick, 1000, true)
  function btnClick () {
    console.log('点击了')
  }
  //输入框防抖
  let oInput = document.getElementById('input')
  oInput.onkeyup = debounce(inputClick, 1000, false)
  function inputClick () {
    let val = this.value
    if (val.length < 6){
      console.log('Invalid length')
    }else {
      console.log('success')
    }
  }
</script>
</body>
</html>

~~~



### 函数节流

事件被触发, n秒内只执行一次处理函数

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        input {
            width: 150px;
            height: 30px;
        }
    </style>
</head>
<body>
<input id="input" type="text">
<script>
  //节流封装函数
  function throttle (fn, delay) {
    let t = null
    let begin = new Date().getTime()
    return function () {
      let _self = this
      let args = arguments
      let cur = new Date().getTime()
      clearTimeout(t)
      if (cur - begin >= delay){
        fn.apply(_self, args)
        begin = cur
      }else{
        t = setTimeout(function () {
          fn.apply(_self, args)
        }, delay)
      }
    }
  }
  let oInput = document.getElementById('input')
  oInput.onkeyup = throttle(check, 1000)
  function check () {
    let val = this.value
    if (val.length < 6){
      console.log('Invalid length')
    }else {
      console.log('success')
    }
  }
</script>
</body>
</html>

~~~



## 前端网络



### 统一资源

URI: Uniform Resource Identifier

- 统一资源标识符

URL: Uniform Resource Locator

- 统一资源定位符
- URL可以用来标识一个资源,并指明如何定位这个资源
- 用地址定义一个资源

URN: Uniform Resource Name

- 统一资源命名
- 用名称定位一个资源

注: URL肯定是一个URI, URI不一定是URL, 也有可能是RRN



### 域名分类

1、通用类(展示中文域名-万网)
     .com: 工商金融等企业     .com.cn    .公司
     .gov: 政府机构  .gov.cn
     .net: 提供互联网网络服务机构   .net.cn    .网络
     .org:各类组织机构
     .ac: 科研机构    .ac.cn
     .edu：教育机构    .edu.cn

2、国家地区类
      cn: 中国 
      ca: 加拿大
      uk: 英国
      jp: 日本
      kr: 韩国
      hk: 中国香港地区
      tw: 中国台湾地区

### DNS解析

DNS:  Domain Name Server (域名服务器)

作用：域名与对应的Ip转换的服务器

特征：DNS中保存了一张域名与对应的Ip地址的表
           一个域名对应一个IP地址，一个IP地址可以对应多个域名

gTLD：generic Top-Level DNS Server 顶级域名服务器
            为所有.com、.net ……后缀做域名解析的服务器



### IP端口号

Ip地址：上海迪斯尼乐园的地址
               IPv4或IPv6
端口号：乐园中的不同游乐设施
               80、443

解释：找到一个IP就像找到了乐园的地址，你就可以到乐园，相当于可以访问到IP所对应的服务器，IP加端口号，相当于到乐园去玩儿不同的项目，每个项目其实就是一个端口号。

总结：每一个端口对应的是一个服务器的一个业务，访问一个服务器的不同端口相当于访问不同的业务。

端口号范围：0 – 65535
默认端口：http协议下（80）、https协议下（443）、FTP协议下（20、21）

node展示端口不同，服务端不同的业务

IP:上海市浦东新区   域名：上海迪士尼乐园     端口：乐园海盗船的入口



### TCP

TCP：Transmission Control Protocol   传输控制协议

特点：面向连接（收发数据前，必须建立可靠的连接）
建立连接基础：三次握手
应用场景：数据必须准确无误的收发HTTP请求、FTP文件传输、邮件收发
优点：稳定、重传机制、拥塞控制机制、断开连接
缺点：速度慢、效率低、占用资源、容易被攻击（三次握手-> DOS、DDOS攻击）

TCP/IP协议组：提供点对点的连接机制，制定了数据封装、定址、传输、路由、数据接收的标准。



### UDP

UDP：User Data Protocol 用户数据报协议

特点：面向无连接（不可靠的协议，无状态传输机制）
无连接信息发送机制
应用场景：无需确保通讯质量且要求速度快、无需确保信息完整
消息收发、语音通话、直播（QQ）
优点：安全、快速、漏洞少（UDP flood攻击）
缺点：不可靠、不稳定、容易丢包

总结：只要目的源地址、端口号、地址、端口号确定，则可以直接发送信息报文，
           但不能保证一定能收到或收到完整的数据。



### HTTP与HTTPS

HTTP: HyperText Transfer Protocol 超文本传输协议
定义：客户端和服务器端请求和应答的标准，用于从WEB服务器传输超文本到本地浏览器
           的传输协议。

HTTP请求：按照协议规则先向WEB服务器发送的将超文本传输到本地浏览器的请求

HTTPS:  HyperText Transfer Protocol Secure 超文本传输安全协议
定义：HTTP的安全版（安全基础是SSL/TLS ）

SSL：Secure Sockets Layer  安全套接层
TLS：Transport Layer Security 传输层安全
为网络通信提供安全及数据完整性的一种安全协议，对网络连接进行加密

区别： （展示携程和腾讯课堂）

1、HTTP是不安全的（监听和中间人攻击等手段，获取网站账户信息和敏感信息）
      HTTPS可防止被攻击

2、HTTP协议的传输内容都是明文，直接在TCP连接上运行，客户端和服务器都无法验证对方身份

3、HTTPS协议的传输内容都被SSL/TLS加密，且运行在SSL/TLS上，SSL/TLS运行在TCP连接上，所以数据传输是安全的。



### 三次握手

第一次握手：客户端向服务器发送SYN标志位（序号是J），并进入SYN_SEND状态（等
                      待服务器确认状态）。

第二次握手：服务器收到来自客户端的SYN J，服务端会确认该数据包已收到并发送ACK
                      标志位（序号是J+1）和SYN标志位（序号是K），服务器进入
                      SYN_RECV（请求接收并等待客户端确认状态）。

第三次握手：客户端进入连接建立状态后，向服务器发送ACK标志位（序号是K+1）确
                      认客户端已收到建立连接确认，服务器收到ACK标志位后，服务端进入连接
                      已建立状态。





## 错误收集

### SyntaxError

语法错误, 检查代码, 修改不符合规范的代码



### ReferenceError

引用错误, 不符合规范的变量声明与赋值



### RangeError

范围错误, 超出数组对象可行范围



### TypeError

类型错误, 函数不存在并被使用或者错误的类型使用



### URIError

统一资源标识错误, 通常出现在encodeURI和decodeURI方法上







# TS

## 配置详解

~~tsconfig.json

文件选项配置

`files` : 表示编译需要编译的单个文件列表

~~~json
"files": [
  // 指定编译文件是src目录下的a.ts文件
  "scr/a.ts"
]
~~~

`include`: 表示编译需要编译的文件或目录

~~~json
"include": [
  // "scr" // 会编译src目录下的所有文件，包括子目录
  // "scr/*" // 只会编译scr一级目录下的文件
  "scr/*/*" // 只会编译scr二级目录下的文件
]
~~~

`exclude`：表示编译器需要排除的文件或文件夹

~~~json
//默认排除node_modules文件夹下文件
"exclude": [
  // 排除src目录下的lib文件夹下的文件不会编译
  "src/lib"
]
~~~

`extends`: 引入其他配置文件，继承配置

~~~json
// 把基础配置抽离成tsconfig.base.json文件，然后引入
"extends": "./tsconfig.base.json"
~~~

`compileOnSave`:设置保存文件的时候自动编译

~~~json
//暂不支持VScode,请使用webstorm
"compileOnSave": true
~~~



编译选项配置

`compilerOptions`:配置编译选项

~~~json
//编译选项配置非常繁杂，有很多配置，这里只列出常用的配置。
"compilerOptions": {
  "incremental": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度
  "tsBuildInfoFile": "./buildFile", // 增量编译文件的存储位置
  "diagnostics": true, // 打印诊断信息 
  "target": "ES5", // 目标语言的版本
  "module": "CommonJS", // 生成代码的模板标准
  "outFile": "./app.js", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置"module": "AMD",
  "lib": ["DOM", "ES2015", "ScriptHost", "ES2019.Array"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入"ES2019.Array",
  "allowJS": true, // 允许编译器编译JS，JSX文件
  "checkJs": true, // 允许在JS文件中报错，通常与allowJS一起使用
  "outDir": "./dist", // 指定输出目录
  "rootDir": "./", // 指定输出文件目录(用于输出)，用于控制输出目录结构
  "declaration": true, // 生成声明文件，开启后会自动生成声明文件
  "declarationDir": "./file", // 指定生成声明文件存放目录
  "emitDeclarationOnly": true, // 只生成声明文件，而不会生成js文件
  "sourceMap": true, // 生成目标文件的sourceMap文件
  "inlineSourceMap": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中
  "declarationMap": true, // 为声明文件生成sourceMap
  "typeRoots": [], // 声明文件目录，默认时node_modules/@types
  "types": [], // 加载的声明文件包
  "removeComments":true, // 删除注释 
  "noEmit": true, // 不输出文件,即编译后不会生成任何js文件
  "noEmitOnError": true, // 发送错误时不输出任何文件
  "noEmitHelpers": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用
  "importHelpers": true, // 通过tslib引入helper函数，文件必须是模块
  "downlevelIteration": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现
  "strict": true, // 开启所有严格的类型检查
  "alwaysStrict": true, // 在代码中注入'use strict'
  "noImplicitAny": true, // 不允许隐式的any类型
  "strictNullChecks": true, // 不允许把null、undefined赋值给其他类型的变量
  "strictFunctionTypes": true, // 不允许函数参数双向协变
  "strictPropertyInitialization": true, // 类的实例属性必须初始化
  "strictBindCallApply": true, // 严格的bind/call/apply检查
  "noImplicitThis": true, // 不允许this有隐式的any类型
  "noUnusedLocals": true, // 检查只声明、未使用的局部变量(只提示不报错)
  "noUnusedParameters": true, // 检查未使用的函数参数(只提示不报错)
  "noFallthroughCasesInSwitch": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)
  "noImplicitReturns": true, //每个分支都会有返回值
  "esModuleInterop": true, // 允许export=导出，由import from 导入
  "allowUmdGlobalAccess": true, // 允许在模块中全局变量的方式访问umd模块
  "moduleResolution": "node", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入
  "baseUrl": "./", // 解析非相对模块的基地址，默认是当前目录
  "paths": { // 路径映射，相对于baseUrl
    // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置
    "jquery": ["node_modules/jquery/dist/jquery.min.js"]
  },
  "rootDirs": ["src","out"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错
  "listEmittedFiles": true, // 打印输出文件
  "listFiles": true// 打印编译的文件(包括引用的声明文件)
}
~~~



工程引用配置

`references` 指定工程引用依赖

~~在项目开发中，有时候我们为了方便将前端项目和后端`node`项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置

~~~json
Project
  - src
    - client //客户端项目
      - index.ts // 客户端项目文件
      - tsconfig.json // 客户端配置文件
        {
          "extends": "../../tsconfig.json", // 继承基础配置
          "compilerOptions": {
            "outDir": "../../dist/client", // 指定输出目录
          },
          "references": [ // 指定依赖的工程
            {"path": "./common"}
          ]
        }
    - common // 前后端通用依赖工程
      - index.ts  // 前后端通用文件
      - tsconfig.json // 前后端通用代码配置文件
        {
          "extends": "../../tsconfig.json", // 继承基础配置
          "compilerOptions": {
            "outDir": "../../dist/client", // 指定输出目录
          }
        }
    - server // 服务端项目
      - index.ts // 服务端项目文件
      - tsconfig.json // 服务端项目配置文件
        {
          "extends": "../../tsconfig.json", // 继承基础配置
          "compilerOptions": {
            "outDir": "../../dist/server", // 指定输出目录
          },
          "references": [ // 指定依赖的工程
            {"path": "./common"}
          ]
        }
  - tsconfig.json // 前后端项目通用基础配置
    {
      "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "strict": true,
        "composite": true, // 增量编译
        "declaration": true
      }
    }
~~~

前端项目构建: tsc -v src/client

后端项目构建: tsc -b src/server

输出目录: 

~~~json
Project
 - dist 
  - client
    - index.js
    - index.d.ts
  - common
    - index.js
    - index.d.ts
  - server
    - index.js
    - index.d.ts
~~~



## 基础类型

boolean

~~~jsx
let isDone: boolean = false;
~~~

number

~~~jsx
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
~~~

string

~~~jsx
//普通
let name: string = "bob";
name = "smith";
//模板
let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.
I'll be ${ age + 1 } years old next month.`;
~~~

Array

~~~jsx
//普通
let list: number[] = [1, 2, 3];
//泛型
let list: Array<number> = [1, 2, 3];
~~~

Tuple(元组)

~~~jsx
// 声明元组类型
let x: [string, number];
// 初始化
x = ['hello', 10]; // OK
// 初始化失败
x = [10, 'hello']; // Error

//当访问一个已知索引的元素，会得到正确的类型
console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // 错误, number没有substr方法

//当访问一个越界的元素，会使用联合类型替代
x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString

x[6] = true; // Error, 布尔不是(string | number)类型
~~~

enum(枚举)

~~~TS
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
//改变枚举编号
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
//通过枚举编号获取相应名字
enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];
alert(colorName);  // 显示'Green'因为上面代码里它的值是2
~~~

any(任意值)

~~~ts
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // 肯定是布尔

//Object可赋任意值但不可调用任意方法
let notSure: any = 4;
notSure.ifItExists(); // 运行时可用
notSure.toFixed(); // 可用,但是编译器不会检查
let prettySure: Object = 4;
prettySure.toFixed(); // 错误:属性“toFixed”不存在于类型“Object”上

//数组内元素不同类型也是可用的
let list: any[] = [1, true, "free"];
list[1] = 100;
~~~

void(空值)

~~~ts
//函数没有返回值
function warnUser(): void {
    alert("This is my warning message");
}
//声明void变量只能赋予undefined和null
let unusable: void = undefined;
~~~

Null 和 Undefined

~~undefined`和`null`两者各自有自己的类型分别叫做undefined`和null 和void相似，它们的本身的类型用处不是很大

~~默认情况下null和undefined是所有类型的子类型,可以把null和undefined赋值给number类型的变量

~~当你指定了--strictNullChecks标记,null和undefined只能赋值给void和它们各自

Never(永不存在的值的类型)

~~~ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
~~~

类型断言

~~~ts
//<>
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
//as
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
//两者等价,在TypeScript里使用JSX时，只有as语法断言是被允许的
~~~

## 接口(interface)

普通对象:

~~~ts
//示例
interface LabelledValue {
  label: string;
}
function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}
let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);

//可选属性
interface SquareConfig {
  color?: string;
  width?: number;
}

//只读属性
interface Point {
    readonly x: number;
    readonly y: number;
}

//属性检测可通过类型断言绕开
let mySquare = createSquare({ colour: "red", width: 100 });
// 错误:“colour”没有在“SquareConfig”类型中出现
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);//ok
~~~

函数类型

~~~ts
interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}

//函数的参数名不需要与接口里定义的名字相匹配
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result > -1;
}

//参数类型和返回值类型系统会自行推断,可不用写
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result > -1;
}
~~~

可索引的类型

~~~ts
//数字索引类型
interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];

//字符串索引类型
interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
~~~

类类型

~~~ts
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

//接口中描述方法,在类中实现
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
~~~

~~ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数createClock，它用传入的类型创建实例。

~~~ts
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick();
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}
//因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名
let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
~~~

继承接口

~~接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里

~~~ts
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
~~~

~~一个接口可以继承多个接口，创建出多个接口的合成接口

~~~ts
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
~~~

混合类型

~~一个对象可以同时做为函数和对象使用，并带有额外的属性

~~~ts
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
~~~

接口继承类

~~当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系

~~~ts
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {

}

// 错误:类型“Image”中缺少属性“state”
class Image implements SelectableControl {
    select() { }
}

class Location {

}
~~~

- 注:在上面的例子里，`SelectableControl`包含了`Control`的所有成员，包括私有成员`state`。 因为`state`是私有成员，所以只能够是`Control`的子类们才能实现`SelectableControl`接口。 因为只有`Control`的子类才能够拥有一个声明于`Control`的私有成员`state`，这对私有成员的兼容性是必需的。

- 注:在`Control`类内部，是允许通过`SelectableControl`的实例来访问私有成员`state`的。 实际上，`SelectableControl`就像`Control`一样，并拥有一个`select`方法。 `Button`和`TextBox`类是`SelectableControl`的子类（因为它们都继承自`Control`并有`select`方法），但`Image`和`Location`类并不是这样的。



## 类(class)

~~引用任何一个类成员的时候都用了`this`。 它表示我们访问的是类的成员

~~使用`new`构造了`Greeter`类的一个实例。 它会调用之前定义的构造函数，创建一个`Greeter`类型的新对象，并执行构造函数初始化它

~~~ts
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
~~~

继承

~~基础的继承

~~~js
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
~~~

~~复杂的继承

~~~js
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
~~~

- 注:派生类包含了一个构造函数，它*必须*调用`super()`，它会执行基类的构造函数。 而且，在构造函数里访问`this`的属性之前，我们*一定*要调用`super()`。 这个是TypeScript强制执行的一条重要规则。Snake`类和`Horse`类都创建了`move`方法，它们重写了从`Animal`继承来的`move`方法，使得`move`方法根据不同的类而具有不同的功能。 注意，即使`tom`被声明为`Animal`类型，但因为它的值是`Horse`，调用`tom.move(34)`时，它会调用`Horse`里重写的方法



公共，私有与受保护的修饰符

~~默认为public(公共的)

~~private(私有的)

~~~js
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // 错误: 'name' 是私有的.
~~~

~~当我们比较带有`private`成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个`private`成员，那么只有当另外一个类型中也存在这样一个`private`成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的 ( protected也应用此规则! )

~~~js
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal("Goat");
let rhino = new Rhino();
let employee = new Employee("Bob");

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
~~~

protected(受保护的)

~~只能在内部即自身与派生类中访问,外部无法访问

~~~ts
class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name)
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // 错误
~~~

~~构造函数也可以标记受保护,但这个类不能在包含它的类的外部被实例化,可以被继承

~~~js
class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee 能够继承 Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的.
~~~

存取器(get和set)

~~通过getters/setters来截取对对象成员的访问,帮助你有效的控制对对象成员的访问

~~只带有`get`不带有`set`的存取器自动被推断为`readonly`

~~~js
let passcode = "secret passcode";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
~~~

静态属性(static)

~~每个实例想要访问这个属性的时候，都要在`origin`前面加上类名

~~~js
class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
~~~

抽象类(abstract)

~~抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含`abstract`关键字并且可以包含访问修饰符

~~~js
abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
~~~



把类当做接口使用

~~~js
class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
~~~



## 函数(function)

~~我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。

~~~js
function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x + y; };
~~~

~~对于返回值，我们在函数和返回值类型之前使用(`=>`)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为`void`而不能留空

~~~js
let myAdd: (baseValue: number, increment: number) => number =
    function(x: number, y: number): number { return x + y; };
~~~

可选参数和默认参数

~~每个函数参数都是必须的,传递给一个函数的参数个数必须与函数期望的参数个数一致.

~~可以通过"?"来实现可选参数

~~可以设置初始化默认值

~~可选参数与末尾的默认参数共享参数类型

~~~js
function buildName(firstName: string, lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // error, too few parameters
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // ah, just right
~~~

剩余参数(arguments)

~~可以把所有参数收集到一个变量里

~~~js
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}

let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
~~~

~~剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（`...`）后面给定的名字，你可以在函数体内使用这个数组

~~~js
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}

let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;
~~~



重载

~~方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用

~~~js
let suits = ["hearts", "spades", "clubs", "diamonds"];

function pickCard(x: {suit: string; card: number; }[]): number;
function pickCard(x: number): {suit: string; card: number; };
function pickCard(x): any {
    // Check to see if we're working with an object/array
    // if so, they gave us the deck and we'll pick the card
    if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];
alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
~~~

- 注:为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面

- `function pickCard(x): any`并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用`pickCard`会产生错误。



## 泛型

~~基础示例

~~~js
function identity<T>(arg: T): T {
    return arg;
}
let output = identity<string>("myString");  // 输出类型为'string'
~~~

~~我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看`myString`的值，然后把`T`设置为它的类型。

~~~js
let output = identity("myString");  // 输出类型为'string'
~~~

~~泛型函数`loggingIdentity`，接收类型参数`T`和参数`arg`，它是个元素类型是`T`的数组，并返回元素类型是`T`的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时`T`的的类型为`number`。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性

~~~js
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);  // 数组有一个.length，所以不会再有错误
    return arg;
}
//也可以这样写
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  //  数组有一个.length，所以不会再有错误
    return arg;
}
~~~

泛型接口

~~~ts
interface GenericIdentityFn<T> {
    (arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;
~~~

泛型类

~~类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型.

~~~js
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
~~~

泛型约束

~~我们定义一个接口来描述约束条件。 创建一个包含`.length`属性的接口，使用这个接口和`extends`关键字还实现约束

~~~ts
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // 现在我们知道它有.length属性，所以不会有错误
    return arg;
}
~~~

~~现在这个泛型函数被定义了约束，因此它不再是适用于任意类型

~~~ts
loggingIdentity(3);  // 错误，数字没有.length属性
~~~

~~我们需要传入符合约束类型的值，必须包含必须的属性

~~~ts
loggingIdentity({length: 10, value: 3});
~~~



在泛型里使用类类型

~~使用原型属性推断并约束构造函数与类实例的关系

~~~ts
class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance<A extends Animal>(c: new () => A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // 类型检查!
createInstance(Bee).keeper.hasMask;   // 类型检查!
~~~

 配合 axios 使用

~~通常情况下，我们会把后端返回数据格式单独放入一个 interface 里

~~~ts
// 请求接口数据
export interface ResponseData<T = any> {
  /**
   * 状态码
   * @type { number }
   */
  code: number;

  /**
   * 数据
   * @type { T }
   */
  result: T;

  /**
   * 消息
   * @type { string }
   */
  message: string;
}
~~~

~~当我们把 API 单独抽离成单个模块时

~~~ts
// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等
import Ax from './axios';

import { ResponseData } from './interface.ts';

export function getUser<T>() {
  return Ax.get<ResponseData<T>>('/somepath')
    .then(res => res.data)
    .catch(err => console.error(err));
}
~~~

~~接着我们写入返回的数据类型 `User`，这可以让 TypeScript 顺利推断出我们想要的类型

~~~ts
interface User {
  name: string;
  age: number;
}

async function test() {
  // user 被推断出为
  // {
  //  code: number,
  //  result: { name: string, age: number },
  //  message: string
  // }
  const user = await getUser<User>();
}
~~~





## 声明空间

类型声明空间:

~~~js
class Foo {}
interface Bar {}
type Bas = {};
//当做注解使用
let foo: Foo;
let bar: Bar;
let bas: Bas;
//未在变量声明空间中定义
interface Bar {}
const bar = Bar; // 错误:"找不到名称'Bar'"
~~~

变量声明空间:
~~`Class Foo` 提供了一个类型 `Foo` 到类型声明空间，此外它同样提供了一个变量 `Foo` 到变量声明空间

~~~js
class Foo {}
const someVar = Foo;
const someOtherVar = 123;
//只能在变量声明空间使用，不能用作类型注解。
const foo = 123;
const foo = 123;
let bar: foo; // 错误:"找不到名称'foo'"
~~~

全局声明空间:

~~在不同文件中也是可以访问的

~~毋庸置疑，使用全局变量空间是危险的，因为它会与文件内的代码命名冲突

~~ foo.ts 

~~~js
const foo = 123;
~~~

~~bar.ts

~~~js
const bar = foo; // 允许
~~~

## 文件模块

~~文件的根级别位置含有 `import` 或者 `export`，那么它会在这个文件中创建一个本地的作用域

~~foo.ts

~~~js
export const foo = 123;
~~~

~~bar.ts

~~~js
const bar = foo; // 错误:"找不到名称'foo'"
~~~

~~bar.ts

~~~js
import { foo } from './foo';
const bar = foo; // 允许
~~~

ES模块语法:

~~导出

~~第一种写法

~~~js
// foo.ts
export const someVar = 123;
export type someType = {
  foo: string;
};
~~~

~~第二种写法

~~~js
// foo.ts
const someVar = 123;
type someType = {
  type: string;
};

export { someVar, someType };
~~~

~~重命名导出

~~~js
// foo.ts
const someVar = 123;
export { someVar as aDifferentName };
~~~

~~导入

~~~js
// bar.ts
import { someVar, someType } from './foo';
~~~

~~重命名导入

~~~js
// bar.ts
import { someVar as aDifferentName } from './foo';
~~~

~~导入所有并命名

~~~js
// bar.ts
import * as foo from './foo';
// 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型
~~~

~~只导入模块

~~~js
import 'core-js'; // 一个普通的 polyfill 库
~~~

~~从其他模块导入后整体导出

~~~js
export * from './foo';
~~~

~~从其他模块导入后，部分导出

~~~js
export { someVar } from './foo';
~~~

~~通过重命名，部分导出从另一个模块导入的项目

~~~js
export { someVar as aDifferentName } from './foo';
~~~



global.d.ts

~~全局文件

~~用来将一些接口或者类型放入全局命名空间里，这些定义的接口和类型能在你的所有 TypeScript 代码里使用





## 命名空间

~~`something || (something = {})` 允许匿名函数 `function (something) {}` 向现有对象添加内容，或者创建一个新对象，然后向该对象添加内容。这意味着你可以拥有两个由某些边界拆成的块。

~~~ts
(function(something) {
  something.foo = 123;
})(something || (something = {}));

console.log(something);
// { foo: 123 }

(function(something) {
  something.bar = 456;
})(something || (something = {}));

console.log(something); // { foo: 123, bar: 456 }
~~~

~~在TS中可以使用namespace关键字来描述这种分组,支持内部嵌套命名空间

~~~ts
namespace Utility {
  export function log(msg) {
    console.log(msg);
  }
  export function error(msg) {
    console.log(msg);
  }
}

// usage
Utility.log('Call me');
Utility.error('maybe');
~~~



## 环境声明

~~使用declare 声明全局变量或者对象,必须在lib.d.ts文件中使用

~~~js
//定义全局变量
declare var Math: Math;
~~~

~~即变量 `Math` 是 `Math` 的一个实例，`Math` 接口被定义为

~~~js
interface Math {
  E: number;
  LN10: number;
  // 其他 ...
}
~~~

~~当你想在 `Math` 全局变量上添加你需要的属性时，你只需要把它添加到 `Math` 的全局接口上即可

~~~ts
interface Math {
  seedrandom(seed?: string): void;
}
~~~

~~你可以像下面一样使用它

~~~ts
Math.seedrandom();

Math.seedrandom('Any string you want');
~~~



## 可调用的

~~一个接口可提供多种调用签名，用以特殊的函数重载

~~~ts
interface Overloaded {
  (foo: string): string;
  (foo: number): number;
}

// 实现接口的一个例子：
function stringOrNumber(foo: number): number;
function stringOrNumber(foo: string): string;
function stringOrNumber(foo: any): any {
  if (typeof foo === 'number') {
    return foo * foo;
  } else if (typeof foo === 'string') {
    return `hello ${foo}`;
  }
}

const overloaded: Overloaded = stringOrNumber;

// 使用
const str = overloaded(''); // str 被推断为 'string'
const num = overloaded(123); // num 被推断为 'number'
~~~

~~支持箭头函数,但只能作为简单的箭头函数使用,无法使用重载

~~~ts
//number类型为参数,string类型为返回值
const simple: (foo: number) => string = foo => foo.toString();
~~~

~~可以实例化调用

~~~ts
interface CallMeWithNewToGetString {
  new (): string;
}

// 使用
declare const Foo: CallMeWithNewToGetString;
const bar = new Foo(); // bar 被推断为 string 类型
~~~



## 类型断言

~~在JS迁移TS时

~~~js
const foo = {};
foo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’
foo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'
~~~

~~通过类型断言解决

~~~ts
interface Foo {
  bar: number;
  bas: string;
}

const foo = {} as Foo;
foo.bar = 123;
foo.bas = 'hello';
~~~

as foo 与 <>foo 

~~最初使用<>foo

~~~ts
let foo: any;
let bar = <string>foo; // 现在 bar 的类型是 'string'
~~~

~~避免在JSX中使用,强烈建议使用as foo语法

~~~ts
let foo: any;
let bar = string as foo;
~~~

双重断言

~~首先断言成兼容所有类型的 `any`，编译器将不会报错

~~~ts
function handler(event: Event) {
  const element = (event as any) as HTMLElement; // ok
}
~~~

## 类型保护

 typeof

~~将会辨别 `string` 上是否存在特定的函数，以及是否发生了拼写错误

~~~ts
function doSome(x: number | string) {
  if (typeof x === 'string') {
    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`
    console.log(x.subtr(1)); // Error: 'subtr' 方法并没有存在于 `string` 上
    console.log(x.substr(1)); // ok
  }

  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型
}
~~~

instanceof

~~~ts
class Foo {
  foo = 123;
  common = '123';
}

class Bar {
  bar = 123;
  common = '123';
}

function doStuff(arg: Foo | Bar) {
  if (arg instanceof Foo) {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  }
  if (arg instanceof Bar) {
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}

doStuff(new Foo());
doStuff(new Bar());
~~~

~~当你使用 `if` 来缩小类型时，TypeScript 知道在其他块中的类型并不是 `if` 中的类型

~~~ts
class Foo {
  foo = 123;
}

class Bar {
  bar = 123;
}

function doStuff(arg: Foo | Bar) {
  if (arg instanceof Foo) {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  } else {
    // 这个块中，一定是 'Bar'
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}

doStuff(new Foo());
doStuff(new Bar());
~~~

in操作符

~~可以安全的检查一个对象上是否存在一个属性，它通常也被作为类型保护使用

~~~ts
interface A {
  x: number;
}

interface B {
  y: string;
}

function doStuff(q: A | B) {
  if ('x' in q) {
    // q: A
  } else {
    // q: B
  }
}
~~~

字面量类型保护

~~~ts
type Foo = {
  kind: 'foo'; // 字面量类型
  foo: number;
};

type Bar = {
  kind: 'bar'; // 字面量类型
  bar: number;
};

function doStuff(arg: Foo | Bar) {
  if (arg.kind === 'foo') {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  } else {
    // 一定是 Bar
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}
~~~

使用自定义的类型保护

~~~ts
// 仅仅是一个 interface
interface Foo {
  foo: number;
  common: string;
}

interface Bar {
  bar: number;
  common: string;
}

// 用户自己定义的类型保护！
function isFoo(arg: Foo | Bar): arg is Foo {
  return (arg as Foo).foo !== undefined;
}

// 用户自己定义的类型保护使用用例：
function doStuff(arg: Foo | Bar) {
  if (isFoo(arg)) {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  } else {
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}

doStuff({ foo: 123, common: '123' });
doStuff({ bar: 123, common: '123' });
~~~



## 字面量类型

字符串字面量

~~~ts
let foo: 'Hello';
foo = 'Bar'; // Error: 'bar' 不能赋值给类型 'Hello'

type CardinalDirection = 'North' | 'East' | 'South' | 'West';

function move(distance: number, direction: CardinalDirection) {
  // ...
}

move(1, 'North'); // ok
move(1, 'Nurth'); // Error
~~~

其他字面量类型

~~同样也提供 `boolean` 和 `number` 的字面量类型

~~~ts
type OneToFive = 1 | 2 | 3 | 4 | 5;
type Bools = true | false;
~~~

推断

~~~ts
function iTakeFoo(foo: 'foo') {}
const test = {
  someProp: 'foo'
};

iTakeFoo(test.someProp); // 错误:字符串类型的参数不能分配给foo类型的参数
~~~

~~这是由于 `test` 被推断为 `{ someProp: string }`，我们可以采用一个简单的类型断言来告诉 TypeScript 你想推断的字面量

~~~ts
function iTakeFoo(foo: 'foo') {}

const test = {
  someProp: 'foo' as 'foo'
};

iTakeFoo(test.someProp); // ok
~~~

~~或者使用类型注解的方式，来帮助 TypeScript 推断正确的类型

~~~ts
function iTakeFoo(foo: 'foo') {}

type Test = {
  someProp: 'foo';
};

const test: Test = {
  // 推断 `someProp` 永远是 'foo'
  someProp: 'foo'
};

iTakeFoo(test.someProp); // ok
~~~

你可以使用带字符串字面量的联合类型，来模拟一个基于字符串的枚举类型，就好像上文中提出的 `CardinalDirection`。你甚至可以使用下面的函数来生成 `key: value` 的结构

~~~ts
// 用于创建字符串列表映射至 `K: V` 的函数
function strEnum<T extends string>(o: Array<T>): { [K in T]: K } {
  return o.reduce((res, key) => {
    res[key] = key;
    return res;
  }, Object.create(null));
}

// 创建 K: V
const Direction = strEnum(['North', 'South', 'East', 'West']);

// 创建一个类型
type Direction = keyof typeof Direction;

// 简单的使用
let sample: Direction;

sample = Direction.North; // Okay
sample = 'North'; // Okay
sample = 'AnythingElse'; // ERROR!
~~~



## 辨析联合类型

当类中含有[字面量成员](https://jkchao.github.io/typescript-book-chinese/typings/literals.html)时，我们可以用该类的属性来辨析联合类型

~~考虑 `Square` 和 `Rectangle` 的联合类型 `Shape`。`Square` 和 `Rectangle`有共同成员 `kind`，因此 `kind` 存在于 `Shape` 中

~~如果你使用类型保护风格的检查（`==`、`===`、`!=`、`!==`）或者使用具有判断性的属性（在这里是 `kind`），TypeScript 将会认为你会使用的对象类型一定是拥有特殊字面量的，并且它会为你自动把类型范围变小

~~~ts
interface Square {
  kind: 'square';
  size: number;
}

interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}

type Shape = Square | Rectangle;

function area(s: Shape) {
  if (s.kind === 'square') {
    // 现在 TypeScript 知道 s 的类型是 Square
    // 所以你现在能安全使用它
    return s.size * s.size;
  } else {
    // 不是一个 square ？因此 TypeScript 将会推算出 s 一定是 Rectangle
    return s.width * s.height;
  }
}
~~~





## 索引签名

可以用字符串访问 JavaScript 中的对象（TypeScript 中也一样），用来保存对其他对象的引用

当你传入一个其他对象至索引签名时，JavaScript 会在得到结果之前会先调用 `.toString` 方法

~~~js
let obj = {
  toString() {
    console.log('toString called');
    return 'Hello';
  }
};

let foo: any = {};
foo[obj] = 'World'; // toString called
console.log(foo[obj]); // toString called, World
console.log(foo['Hello']); // World
~~~





# Git

## 常用命令

***** git config --global user.name "username"				 //配置用户名 

***** git config --global user.email "xx@gmail.com" 		//配置邮箱 

***** git init 																				//初始化生成一个本地仓库 

***** git add . 																			//添加到暂存区 

***** git commit –m "message" 											//提交到本地仓库 

***** git remote add origin url 												//关联到远程仓库 

***** git push origin master													 //推送本地 master 分支到远程 master 分支 

***** git checkout -b dev 														//创建一个开发分支并切换到新分支 

***** git push ogigin dev 														//推送本地 dev 分支到远程 dev 分支 

***** git pull origin dev 															//从远程 dev 分支拉取到本地 dev 分支 

***** git clone url																	 //将远程仓库克隆下载到本地



## 命令总览

git branch 查看本地所有分支
git status 查看当前状态 
git commit 提交 
git branch -a 查看所有的分支
git branch -r 查看远程所有分支
git commit -am "init" 提交并且加注释 
git remote add origin git@192.168.1.119:ndshow 添加远程地址
git push origin master 将文件给推到服务器上 
git remote show origin 显示远程库origin里的资源 
git push origin master:develop
git push origin master:hb-dev 将本地库与服务器上的库进行关联 
git checkout --track origin/dev 切换到远程dev分支
git branch -D master develop 删除本地库develop
git checkout -b dev 建立一个新的本地分支dev
git merge origin/dev 将分支dev与当前分支进行合并
git checkout dev 切换到本地dev分支
git remote show 查看远程库
git add .
git rm 文件名(包括路径) 从git中删除指定文件
git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来
git config --list 看所有用户
git ls-files 看已经被提交的
git rm [file name] 删除一个文件
git commit -a 提交当前repos的所有的改变
git add [file name] 添加一个文件到git index
git commit -v 当你用－v参数的时候可以看commit的差异
git commit -m "This is the message describing the commit" 添加commit信息
git commit -a -a是代表add，把所有的change加到git index里然后再commit
git commit -a -v 一般提交命令
git log 看你commit的日志
git diff 查看尚未暂存的更新
git rm a.a 移除文件(从暂存区和工作区中删除)
git rm --cached a.a 移除文件(只从暂存区中删除)
git commit -m "remove" 移除文件(从Git中删除)
git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged 查看尚未提交的更新
git stash push 将文件给push到一个临时空间中
git stash pop 将文件从临时空间pop下来





# ES6

## 字符串新增方法

String.fromCodePoint()

~~用于从 Unicode 码点返回对应字符，如果`String.fromCodePoint`方法有多个参数，则它们会被合并成一个字符串返回。

~~~js
String.fromCodePoint(0x20BB7)
// "𠮷"
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
~~~

- 注意，`fromCodePoint`方法定义在`String`对象上，而`codePointAt`方法定义在字符串的实例对象上



String.raw()

~~该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。

~~~js
String.raw`Hi\n${2+3}!`
// 实际返回 "Hi\\n5!"，显示的是转义后的结果 "Hi\n5!"

String.raw`Hi\u000A!`;
// 实际返回 "Hi\\u000A!"，显示的是转义后的结果 "Hi\u000A!"
~~~



实例方法：codePointAt()

~~可处理4个字节的字符,返回十进制码点

~~~js
let s = '𠮷a';
//0和1表示上面汉子的前两个字节和后两个字节
s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97
~~~



实例方法：includes(), startsWith(), endsWith()

- **includes()**：返回布尔值，表示是否找到了参数字符串。
- **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。

~~~js
let s = 'Hello world!';

s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true
~~~

~~这三个方法都支持第二个参数，表示开始搜索的位置

~~~js
let s = 'Hello world!';

s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
~~~



实例方法：repeat()

~~`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。

~~~js
'x'.repeat(3) // "xxx"
'hello'.repeat(2) // "hellohello"
'na'.repeat(0) // ""
~~~



实例方法：padStart()，padEnd()

~~`padStart()`用于头部补全，`padEnd()`用于尾部补全。

~~`padStart()`和`padEnd()`一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。省略第二个参数，默认使用空格补全长度

~~~js
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'

'x'.padStart(4) // '   x'
'x'.padEnd(4) // 'x   '
//另一个用途是提示字符串格式
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
~~~



实例方法：trimStart()，trimEnd()

~~消除头部和尾部空格,返回新字符串

~~浏览器还部署了额外的两个方法，`trimLeft()`是`trimStart()`的别名，`trimRight()`是`trimEnd()`的别名

~~~js
const s = '  abc  ';

s.trim() // "abc"
s.trimStart() // "abc  "
s.trimEnd() // "  abc"
~~~



实例方法：replaceAll()

~~替换所有匹配字符,返回新的字符串

~~第一个参数可以是正则,但必须带上g修饰符,否则报错!

~~第二个参数可以是函数,必须返回要替换的字符

~~~js
'aabbcc'.replace('b', '_')
// 'aa_bcc'
'aabbcc'.replace(/b/g, '_')
// 'aa__cc'
'aabbcc'.replaceAll('b', () => '_')
// 'aa__cc'
~~~



## 正则扩展

RegExp 构造函数

~~可以使用第二个参数来指定正则的修饰符

~~~js
//原有正则对象的修饰符是ig，它会被第二个参数i覆盖
new RegExp(/abc/ig, 'i').flags
// "i"
~~~



字符串的正则方法

字符串对象共有 4 个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。

ES6 将这 4 个方法，在语言内部全部调用`RegExp`的实例方法，从而做到所有与正则相关的方法，全都定义在`RegExp`对象上。

- `String.prototype.match` 调用 `RegExp.prototype[Symbol.match]`
- `String.prototype.replace` 调用 `RegExp.prototype[Symbol.replace]`
- `String.prototype.search` 调用 `RegExp.prototype[Symbol.search]`
- `String.prototype.split` 调用 `RegExp.prototype[Symbol.split]`



u 修饰符

~~含义为“Unicode 模式”，用来正确处理大于`\uFFFF`的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。

```javascript
/^\uD83D/u.test('\uD83D\uDC2A') // false
/^\uD83D/.test('\uD83D\uDC2A') // true
```

~~如果不添加`u`修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

~~~js
var s = '𠮷';

/^.$/.test(s) // false
/^.$/u.test(s) // true
~~~

~~如果不加`u`修饰符，正则表达式无法识别`\u{61}`这种表示法，只会认为这匹配 61 个连续的`u`

~~~js
/\u{61}/.test('a') // false
/\u{61}/u.test('a') // true
/\u{20BB7}/u.test('𠮷') // true
~~~

~~使用`u`修饰符后，所有量词都会正确识别码点大于`0xFFFF`的 Unicode 字符

~~~js
/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true
/𠮷{2}/.test('𠮷𠮷') // false
/𠮷{2}/u.test('𠮷𠮷') // true
~~~

~~`\S`是预定义模式，匹配所有非空白字符。只有加了`u`修饰符，它才能正确匹配码点大于`0xFFFF`的 Unicode 字符

~~~js
/^\S$/.test('𠮷') // false
/^\S$/u.test('𠮷') // true
~~~



## 数值扩展

Number.isFinite()

~~Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是`Infinity

~~~js
//不是数值类型一律返回false
Number.isFinite(15); // true
Number.isFinite(0.8); // true
Number.isFinite(NaN); // false
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
Number.isFinite('foo'); // false
Number.isFinite('15'); // false
Number.isFinite(true); // false
~~~



Math 对象的扩展



Math.trunc()

~~`Math.trunc`方法用于去除一个数的小数部分，返回整数部分

~~~js
Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
~~~



## 装饰器

~~装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法

~~装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。

1. 类的装饰

~~~js
@testable
class MyTestableClass {
  // ...
}

function testable(target) {
  target.isTestable = true;
}

MyTestableClass.isTestable // true

//@testable就是一个装饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。


@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;

//装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类
~~~

~~如果觉得一个参数不够用，可以在装饰器外面再封装一层函数

~~~js
function testable(isTestable) {
  return function(target) {
    target.isTestable = isTestable;
  }
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable // true

@testable(false)
class MyClass {}
MyClass.isTestable // false
~~~

~~如果想添加实例属性，可以通过目标类的`prototype`对象操作

~~~js
function testable(target) {
  target.prototype.isTestable = true;
}

@testable
class MyTestableClass {}

let obj = new MyTestableClass();
obj.isTestable // true
~~~

~~通过装饰器`mixins`，把`Foo`对象的方法添加到了`MyClass`的实例上面。可以用`Object.assign()`模拟这个功能

~~~js
// mixins.js
export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list)
  }
}

// main.js
import { mixins } from './mixins'

const Foo = {
  foo() { console.log('foo') }
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo() // 'foo'
~~~

~~实际开发中，React 与 Redux 库结合使用时

~~~js
class MyReactComponent extends React.Component {}
export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);

//等同于

@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component {}
~~~

2. 方法的装饰

~~~js
class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}

function readonly(target, name, descriptor){
  // descriptor对象原来的值如下
  // {
  //   value: specifiedFunction,
  //   enumerable: false,
  //   configurable: true,
  //   writable: true
  // };
  descriptor.writable = false;
  return descriptor;
}

readonly(Person.prototype, 'name', descriptor);
// 类似于
Object.defineProperty(Person.prototype, 'name', descriptor);

//装饰器第一个参数是类的原型对象，上例是Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时target参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象
~~~

~~`@log`装饰器的作用就是在执行原始的操作之前，执行一次`console.log`，从而达到输出日志的目的

~~~js
class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

function log(target, name, descriptor) {
  var oldValue = descriptor.value;

  descriptor.value = function() {
    console.log(`Calling ${name} with`, arguments);
    return oldValue.apply(this, arguments);
  };

  return descriptor;
}

const math = new Math();

// passed parameters should get logged now
math.add(2, 4);
~~~

~~如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。

~~~js
function dec(id){
  console.log('evaluated', id);
  return (target, property, descriptor) => console.log('executed', id);
}

class Example {
    @dec(1)
    @dec(2)
    method(){}
}
// evaluated 1
// evaluated 2
// executed 2
// executed 1
// 外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行
~~~



3. 为什么装饰器不能用于函数

~~~js
var counter = 0;

var add = function () {
  counter++;
};

@add
function foo() {
}

//实际执行是:

var counter;
var add;

@add
function foo() {
}

counter = 0;

add = function () {
  counter++;
};

//装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升
~~~

~~如果一定要装饰函数，可以采用高阶函数的形式直接执行

~~~js
function doSomething(name) {
  console.log('Hello, ' + name);
}

function loggingDecorator(wrapped) {
  return function() {
    console.log('Starting');
    const result = wrapped.apply(this, arguments);
    console.log('Finished');
    return result;
  }
}

const wrapped = loggingDecorator(doSomething);
~~~



4. core-decorators.js 

~~[core-decorators.js](https://github.com/jayphelps/core-decorators.js)是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。

**（1）@autobind**

`autobind`装饰器使得方法中的`this`对象，绑定原始对象。

```javascript
import { autobind } from 'core-decorators';

class Person {
  @autobind
  getPerson() {
    return this;
  }
}

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
```

**（2）@readonly**

`readonly`装饰器使得属性或方法不可写。

```javascript
import { readonly } from 'core-decorators';

class Meal {
  @readonly
  entree = 'steak';
}

var dinner = new Meal();
dinner.entree = 'salmon';
// Cannot assign to read only property 'entree' of [object Object]
```

**（3）@override**

`override`装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。

```javascript
import { override } from 'core-decorators';

class Parent {
  speak(first, second) {}
}

class Child extends Parent {
  @override
  speak() {}
  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)
}

// or

class Child extends Parent {
  @override
  speaks() {}
  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.
  //
  //   Did you mean "speak"?
}
```

**（4）@deprecate (别名@deprecated)**

`deprecate`或`deprecated`装饰器在控制台显示一条警告，表示该方法将废除。

```javascript
import { deprecate } from 'core-decorators';

class Person {
  @deprecate
  facepalm() {}

  @deprecate('We stopped facepalming')
  facepalmHard() {}

  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })
  facepalmHarder() {}
}

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: We stopped facepalming

person.facepalmHarder();
// DEPRECATION Person#facepalmHarder: We stopped facepalming
//
//     See http://knowyourmeme.com/memes/facepalm for more details.
//
```

**（5）@suppressWarnings**

`suppressWarnings`装饰器抑制`deprecated`装饰器导致的`console.warn()`调用。但是，异步代码发出的调用除外。

```javascript
import { suppressWarnings } from 'core-decorators';

class Person {
  @deprecated
  facepalm() {}

  @suppressWarnings
  facepalmWithoutWarning() {
    this.facepalm();
  }
}

let person = new Person();

person.facepalmWithoutWarning();
// no warning is logged
```



5. Mixin

在装饰器的基础上，可以实现`Mixin`模式。所谓`Mixin`模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法

~~~js
//mixins.js
export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list);
  };
}
//可以使用上面这个装饰器，为类“混入”各种方法
import { mixins } from './mixins';

const Foo = {
  foo() { console.log('foo') }
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo() // "foo"
~~~



~~`MyMixin`是一个混入类生成器，接受`superclass`作为参数，然后返回一个继承`superclass`的子类，该子类包含一个`foo`方法，接着，目标类再去继承这个混入类，就达到了“混入”`foo`方法的目的

~~~js
let MyMixin = (superclass) => class extends superclass {
  foo() {
    console.log('foo from MyMixin');
  }
};

class MyClass extends MyMixin(MyBaseClass) {
  /* ... */
}

let c = new MyClass();
c.foo(); // "foo from MyMixin"
~~~

如果需要“混入”多个方法，就生成多个混入类。

这种写法的一个好处，是可以调用`super`，因此可以避免在“混入”过程中覆盖父类的同名方法。

~~~js

let Mixin1 = (superclass) => class extends superclass {
  foo() {
    console.log('foo from Mixin1');
    if (super.foo) super.foo();
  }
};

let Mixin2 = (superclass) => class extends superclass {
  foo() {
    console.log('foo from Mixin2');
    if (super.foo) super.foo();
  }
};

class S {
  foo() {
    console.log('foo from S');
  }
}

class C extends Mixin1(Mixin2(S)) {
  foo() {
    console.log('foo from C');
    super.foo();
  }
}

//每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来

new C().foo()
// foo from C
// foo from Mixin1
// foo from Mixin2
// foo from S
~~~



Trait

[traits-decorator](https://github.com/CocktailJS/traits-decorator)这个第三方模块作为例子。这个模块提供的`traits`装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数



# 移动端

## 基本概念

屏幕尺寸:	对角线的长度 (厘米)

屏幕分辨率:	横纵向上物理像素的个数 (物理像素)

屏幕密度:	每英寸上物理像素的个数

视口尺寸:	代表的横纵向上css像素的个数 (css像素)

像素比:	物理像素/设备独立像素	一个方向上占据的物理像素/一个方向上占据的css像素的个数

## 四个像素

1. 物理像素:	

分辨率,是屏幕呈像的最小单位, 一个物理像素占据的实际屏幕尺寸在不同设备上是不一样的;

设备出厂时,该款设备所包含的物理像素点数和一个物理像素所占据的实际屏幕尺寸是不会变的



2. css像素:

是web开发者使用的最小单位

一个css像素最终一定会转成物理像素去屏幕上呈像

一个css像素到底占据多少个物理像素和屏幕的特性与用户的缩放行为有关

- 不考虑用户缩放

  没有viewport:

  这块屏幕横向上占据了多少个物理像素 (横向分辨率)

  这块屏幕横向上占据了多少个css像素 (视觉视口的横向尺寸)

  有viewport:

  像素比

  一个方向上占据的物理像素/一个方向上占据的css像素的个数

- 考虑用户缩放

  在屏幕的特性的基础上:

  放大: css像素占据更多的物理像素

  缩小: css像素占据更少的物理像素



3. 设备独立像素

是设备对接css像素的接口, 一旦css像素与独立像素挂钩 (width=device-width)

此时像素比才能发挥真正的作用



4. 位图像素

图片的最小单位

位图像素与物理像素一比一时,图片才能完美清晰的展示





## 三个视口

1. 布局视口

   决定页面的布局

2. 视觉视口

   决定用户看到什么

   一个css像素到底占据多少个物理像素和视觉视口有极大的关系

   一个视觉视口包含的物理像素的个数是确定的 (分辨率)

   一个视觉视口包含的css像素的个数是不确定的 (用户的缩放行为有关)

   一个视觉视口的实际尺寸是确定的 (屏幕尺寸)

3. 理想视口

   设备独立像素所代表的值



var layout = document.documentElement.clientWidth;	//布局视口的宽度, 没有兼容性问题

var visual = window.innerWidth;	//视觉视口, 接近全部支持

var dream = screen.width;	//一半代表理想视口的宽度, 一半代表设备分辨率!!有很大的兼容性问题



## 两个动作

放大:	一个css像素的面积变大,视觉视口内css像素的个数变少,视觉视口的尺寸变小,布局视口不变

缩小:	一个css像素的面积变小,视觉视口内css像素的个数变多,视觉视口的尺寸变大,布局视口不变

系统缩放参照于理想视口进行缩放, 改变的是布局视口和视觉视口



## 三个意外

1. 太大的元素

使用完美视口解决太大元素超过视觉视口后不出现滚动条的问题

完美视口:

<meta name="viewport" content="width=device-width,
                               height=device-height,
                               initial-scale=1.0,
                               user-scalable=no,
                               minimum-scale=1.0,
                               maximum-scale=1.0,
                               target-densitydpi=device-dpi">
//initial-scale		初始缩放比例
//user-scalable		是否允许缩放 (no||yes)默认允许
//minimum-scale		允许缩放的最小比例
//maximum-scale		允许缩放的最大比例



2. width=device-width与initial-scale的冲突:

​		initial-scale=1.0时布局视口为375px,

​		initial-scale=0.5时布局视口为750px, 

​		initial-scale=2.0时布局视口为187.5px	(width=device-width存在默认布局视口为375)

​		结论:	谁的布局视口大则决定使用谁!



3. 等比问题

   没有viewport:

   等比,页面展示太小,用户体验不好

   有viewport:

   不等比

   每一个css像素在不同设备占据的实际屏幕尺寸一样

   每一个css像素在不同设备占据的物理像素个数不一样 (像素比)

   一个物理像素占据的实际屏幕尺寸在不同设备上是不一样的



## 适配

em:	自身的font-size

rem:	根标签html的fontsize (改变了一个元素在不同设备上占据的css像素的个数)

viewport:	将所有设备布局视口的宽度调整为设计图的宽度

- 原理: 每一个元素在不同设备上占据的css像素的个数是一样的,但是css像素和物理像素的比例是不一样的,等比的
- 适配的优点: 所量即所得
- 适配的缺点: 没有使用完美视口

~~~js
//1
var targetW = 640
var scale = screen.width/targetW
var meta = document.createElement("meta")
meta.name = "viewport"
meta.content = "initial-scale=" + scale + ",minimum-scale=" + scale + ",maximum-scale=" +
    scale + ",user-scalable=no";
document.head.appendChild(meta);

//2
(function(){
    var targetW = 640;
    var scale = document.documentElement.clientWidth/targetW;
    var meta = document.querySelectir("meta[name='viewport']");
    meta.content = "initial-scale=" + scale + ",minimum-scale=" + scale + 
        ",maximum-scale=" + scale + ",user-scalable=no";
})()
~~~

j





# EGG

## node.js进程

child_process模块:	创建子进程模块

1.exec:	创建子进程并缓存执行结果然后返回

~~~js
const {exec} = require('child_process')
//error创建子进程报错
//stdout创建成功的返回值
//stderr创建失败的返回值
exec('cat a.js', (error, stdout, stderr)=>{
	if(error){
		console.log('报错')
		return
	}
})
~~~



2.spawn: 	创建子进程并缓存执行结果然后返回Streams流

~~~js
const {spawn} = require('child_process')
const ls = spawn('ls', ['-a'], {encoding: 'utf8'});
ls.stdout.on('data', (data)=>{
    console.log(data)
})
ls.stderr.on('data', (data)=>{
    console.log(data)
})
ls.on('close', (code)=>{
    console.log(code)
})
~~~



cluster模块:	CPU资源利用

~~~js
const cluster = require('cluster')

const http = require('http')
const os = require('os')

const cpus = os.cpus().length //cup个数

if(cluster.isMaster){
    console.log(`主进程${process.pid} 正在运行`)
    //衍生工作进程
    for (let i = 0; i<cpus; i++) {
        cluster.fork()
    }
} else {
    //工作进程可以共享任何tcp连接
    //这里我们共享的是一个http服务器
    http.createServer((req, res)=>{
        res.writeHead(200, {'Content-type': 'text/html; charset=utf-8'})
        res.write('123')
        res.end()
    }).listen(8000)

    console.log(`工作进程 ${process.pid} 已经启动`)
}
~~~



主进程与子进程通信

child.js:

~~~js
console.log(`子进程${process.pid}`)
process.on('message', ()=>{
	console.log(`来自master: ${msg}`)
})
process.send('这是子进程')
~~~

master.js:

~~~js
const { fork } require('child_process')
const child = fork('./child.js')
child.on('message', (msg)=>{
    console.log(`来自子进程:${msg}`)
})
child.send('来自master')
~~~



## 配置连接数据库

安装egg-mysql:

~~~js
yarn add egg-mysql -S
~~~



config/pligin.js:

~~~js
exports.mysql = {
    enable: true,
    package: 'egg-mysql'
}
~~~

config/config-default.js:

~~~js
config.mysql = {
    client: {
      // host
      host: 'localhost',
      // 端口号
      port: '3306',
      // 用户名
      user: 'root',
      // 密码
      password: '123456',
      // 数据库名
      database: 'test',
    },
    // 是否加载到 app 上，默认开启
    app: true,
    // 是否加载到 agent 上，默认关闭
    agent: false,
  };
~~~



配置service:

~~~js
// app/service/user.js

'use strict';

const Service = require('egg').Service;

class UserService extends Service {
  async find() {
  // "users" 为test数据库数据表名
    const user = await this.app.mysql.query('select * from users', '');
    return { user };
  }
}

module.exports = UserService;
~~~

配置controller:

~~~js
// app/controller/home.js

'use strict';

const Controller = require('egg').Controller;

class HomeController extends Controller {
  async index() {
    const { ctx } = this;
    const user = await ctx.service.user.find();
    ctx.body = user;
  }
}

module.exports = HomeController;
~~~

配置router.js:

~~~js
//app/router.js

'use strict';

/**
 * @param {Egg.Application} app - egg application
 */
 
module.exports = app => {
  const { router, controller } = app;
  router.get('/', controller.home.index);
};
~~~



- 注意:	mysql8.0 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password,所以用mysql8之后的版本,执行yarn dev运行项目时会报错
- 解决:	
  - use mysql; 
  - alter user 'root'@'localhost' identified with mysql_native_password by '你的密码';
  -  flush privileges;
  - 再次执行yarn dev运行项目即可





# 数据结构

## 时间复杂度

是一个函数,用大O表示, 例: O(1)  O(n)  O(logN)

定性描述该算法的运行时间

O(1) + O(n) = O(n) 		取最大的那个

O(n) * O(n) = O(n^2)		



## 空间复杂度

是一个函数,用大O表示, 例: O(1)  O(n)  O(n^2)

算法在运行过程中临时占用存储空间大小的量度



## 栈

先进后出, 后进先出

模拟:

~~~js
const stack = []
stack.push(1)
stack.push(2)

const item1 = stack.pop()
const item2 = stack.pop()
~~~

LeetCode示例: 第20题

~~~js
var isValid = function(s) {
    if(s.length % 2 === 1) {return false;}
    const stack = []
    for(let i = 0; i < s.length; i += 1){
        const c = s[i]
        if (c === '(' || c === '[' || c === '{') {
            stack.push(c);
        }else{
            const t = stack[stack.length - 1]
            if(
                (t === '(' && c === ')') ||
                (t === '[' && c === ']') ||
                (t === '{' && c === '}')
            ){
                stack.pop()
            }else{
                return false
            }
        }
    }
    return stack.length === 0
};
~~~





## 队列

先进先出

模拟:

~~~js
const stack = []
stack.push(1)
stack.push(2)

const item1 = stack.shift()
const item2 = stack.shift()
~~~

LeetCode示例: 第933题

~~~js
var RecentCounter = function() {
    this.q = []
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
    this.q.push(t)
    while(this.q[0] < t-3000){
        this.q.shift()
    }
    return this.q.length
};
~~~



## 链表

多个元素组成的列表

元素存储不连续, 用next指针连接

模拟:

~~~js
const a = { val: 'a' }
const b = { val: 'b' }
const c = { val: 'c' }
const d = { val: 'd' }
a.next = b
b.next = c
c.next = d

let p = a
while (p){
    console.log(p.next)
    p = p.next
}
~~~

LeetCode示例: 第237题

~~~js
var deleteNode = function(node) {
    node.val = node.next.val
    node.next = node.next.next
};
~~~



LeetCode示例: 第206题

~~~js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let p1 = head //{1,2,3,4,5}
    let p2 = null
    while(p1){
        console.log(p1)
        const tmp = p1.next //tmp = [2,3,4,5]
        console.log(tmp)
        p1.next = p2  //p1.next = null
        console.log(p1.next)
        p2 = p1     //p2 = [1]
        console.log(p2)
        p1 = tmp    //p1 = [2,3,4,5]  继续循环
        console.log(p1)
    }
    return p2   //[5,4,3,2,1]
};
~~~



LeetCode示例: 第2题

~~~js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    const l3 = new ListNode(0)
    let p1 = l1
    let p2 = l2
    let p3 = l3
    let carry = 0
    while(p1 || p2){
        const v1 = p1 ? p1.val : 0
        const v2 = p2 ? p2.val : 0
        const val = v1 + v2 + carry
        carry = Math.floor(val/10)
        p3.next = new ListNode(val % 10) 
        if (p1) p1 = p1.next
        if (p2) p2 = p2.next
        p3 = p3.next
    }
    if (carry) {
        p3.next = new ListNode(carry) 
    }
    return l3.next
};
~~~

LeetCode示例: 第141题

~~~js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let p1 = head
    let p2 = head
    while(p1 && p2 && p2.next){
        p1 = p1.next
        p2 = p2.next.next
        if(p1 === p2){
            return true
        }
    }
    return false
};
~~~

LeetCode示例: 第83题

~~~js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    let p = head
    while (p && p.next){
        if(p.val === p.next.val){
            p.next = p.next.next
        }else{
            p = p.next
        }
        
    }
    return head
};
~~~



## 集合

一种无序且唯一的数据结构

ES6中有集合:Set

常用操作: 去重, 判断元素是否在集合中, 求交集

实操:

~~~js
const arr = [1,1,2,2]

const arr1 = new Set(arr)

const arr2 = [...new Set(arr)]

const has = arr1.has(1)

const set = new Set([2,3])

const set3 = new Set([...arr1].filter(item => set.has(item)))
const set4 = new Set([...arr1].filter(item => !set.has(item)))

console.log(
    arr2,
    arr1,
    has,
    set3,
    set4
)

let mySet = new Set()

mySet.add(1)
mySet.add(2)
mySet.add(3)
mySet.add(4)
mySet.add(5)
mySet.delete(1)

for (let item of mySet) console.log(item)
for (let item of mySet.keys()) console.log(item)
for (let item of mySet.values()) console.log(item)
for (let [key, value] of mySet.entries()) console.log(key, value)

const myArr = Array.from(mySet)

console.log(mySet, myArr)
~~~



LeetCode示例: 第349题

~~~js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    //1:
    const arr1 = new Set(nums1)
    const arr2 = new Set(nums2)
    const set3 = new Set([...arr2].filter(item => arr1.has(item)))
    return [...set3]
    //2: 
    //return [...new Set(nums1)].filter(n => nums2.includes(n))
};
~~~



## 字典

与集合类似, 字典也是存储唯一值的数据结构, 但它是以键值对的形式存储

ES6中有字典:Map

实操:

~~~js
const m = new Map()
//增
m.set('a', '123456')
m.set('b', '123456')
//删
m.delete('a')
//改
m.set('b', '456456')
//查
const u = m.get('b')

console.log(u)
~~~



LeetCode示例: 第349题

~~~js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    const map = new Map()
    nums1.forEach(n => {
        map.set(n, true)
    })
    const res = []
    nums2.forEach(n => {
        if(map.get(n)){
            res.push(n)
            map.delete(n)
        }
    })
    return res
};
~~~

LeetCode示例: 第20题

~~~js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if(s.length % 2 === 1) {return false;}
    const stack = []
    const map = new Map()
    map.set('(', ')')
    map.set('[', ']')
    map.set('{', '}')
    for(let i = 0; i < s.length; i += 1){
        const c = s[i]
        if (map.has(c)) {
            stack.push(c);
        }else{
            const t = stack[stack.length - 1]
            if(map.get(t) === c){
                stack.pop()
            }else{
                return false
            }
        }
    }
    return stack.length === 0
};
~~~

LeetCode示例: 第1题

~~~js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const map = new Map()
    for(let i = 0; i < nums.length; i++){
        const n = nums[i]
        const n2 = target - n
        if(map.has(n2)){
            return [map.get(n2), i]
        }else{
            map.set(n, i)
        }
    }
};
~~~

LeetCode示例: 第3题

~~~js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let l = 0
    let res = 0
    const map = new Map()
    for(let i = 0; i < s.length; i++){
        if(map.has(s[i]) && map.get(s[i]) >= l){
            l = map.get(s[i]) + 1
        }
        res = Math.max(res, i-l+1)
        map.set(s[i], i)
    }
    return res
};
~~~

LeetCode示例: 第76题

~~~js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    let l = 0
    let r = 0
    const map = new Map()
    for(let c of t){
        map.set(c, map.has(c) ? map.get(c) + 1 : 1)
    }
    let size = map.size
    let res = ''
    while(r < s.length){
        const c = s[r]
        if(map.has(c)){
            map.set(c, map.get(c) - 1)
            if(map.get(c) === 0) size -=1
        }
        while(size === 0){
            const newRes = s.substring(l, r + 1)
            if(!res || newRes.length < res.length) res = newRes
            const c2 = s[l]
            if(map.has(c2)){
                map.set(c2, map.get(c2) + 1)
                if(map.get(c2) === 1) size += 1
            }
            l += 1
        }
        r += 1
    }
    return res
};
~~~



## 树

一种分层数据的抽象模型

例如: DOM树, 级联选择, 树形控件

常用操作: 深度/广度优先遍历, 先中后序遍历

实操:

~~~js
const tree = {
    val: 'a',
    children:[
        {
            val: 'b',
            children:[
                {
                    val: 'd',
                    children:[

                    ]
                },
                {
                    val: 'e',
                    children:[

                    ]
                }
            ]
        },
        {
            val: 'c',
            children:[
                {
                    val: 'f',
                    children:[

                    ]
                },
                {
                    val: 'g',
                    children:[

                    ]
                }
            ]
        }
    ]
}
//广度遍历
const afs = (root) => {
    const q = [root]
    while (q.length>0){
        const n = q.shift()
        console.log(n.val)
        n.children.forEach(child => {
            q.push(child)
        })
    }
}
//深度遍历
const dfs = (root) => {
    console.log(root.val)
    root.children.forEach(dfs)
}
//执行
afs(tree)
dfs(tree)
~~~



## 二叉树

树中每个节点最多只能有两个子节点

在js中通常用Object模拟二叉树

实操:

~~~js
const bt = {
    val: 1,
    left: {
        val: 2,
        left: {
            val: 4,
            left: null,
            right: null
        },
        right: {
            val: 5,
            left: null,
            right: null
        }
    },
    right: {
        val: 3,
        left: {
            val: 6,
            left: null,
            right: null
        },
        right: {
            val: 7,
            left: null,
            right: null
        }
    }
}
//先序遍历
const preorder1 = (root) => {
    if (!root){ return  }
    console.log(root.val)
    preorder1(root.left)
    preorder1(root.right)
}
preorder1(bt)
//非递归版
const preorder2 = (root) => {
    if (!root){ return  }
    const stack = [root]
    while (stack.length) {
        const n = stack.pop()
        console.log(n.val)
        if (n.right) stack.push(n.right)
        if (n.left) stack.push(n.left)
    }
}
preorder2(bt)
//中序遍历
const inorder1 = (root) => {
    if (!root){ return  }
    inorder1(root.left)
    console.log(root.val)
    inorder1(root.right)
}
inorder1(bt)
//非递归版
const inorder2 = (root) => {
    if (!root){ return  }
    const stack = []
    let p = root
    while (stack.length || p) {
        while (p) {
            stack.push(p)
            p = p.left
        }
        const n = stack.pop()
        console.log(n.val)
        p = n.right
    }
}
inorder2(bt)
//后序遍历
const postorder1 = (root) => {
    if (!root){ return  }
    postorder1(root.left)
    postorder1(root.right)
    console.log(root.val)
}
postorder1(bt)
//非递归版
const postorder2 = (root) => {
    if (!root){ return  }
    const outputStack = []
    const stack = [root]
    while (stack.length) {
        const n = stack.pop()
        outputStack.push(n)
        if (n.left) stack.push(n.left)
        if (n.right) stack.push(n.right)
    }
    while (outputStack.length) {
        const n = outputStack.pop()
        console.log(n.val)
    }
}
postorder2(bt)
~~~

LeetCode示例: 第104题

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    let res = 0
    const dfs = (n, l) => {
        if(!n){return}
        if(!n.left && !n.right){
       		res = Math.max(res, l)
        }
        dfs(n.left, l+1)
        dfs(n.right, l+1)
    }
    dfs(root, 1)
    return res
};
~~~



LeetCode示例: 第111题

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root){return 0}
    const q = [[root, 1]];
    while(q.length){
        const [n, l] = q.shift()
        if(!n.left && !n.right){
            return l
        }
        if(n.left)q.push([n.left, l+1])
        if(n.right)q.push([n.right, l+1])
    }
};
~~~

LeetCode示例: 第102题

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
//方式1
var levelOrder = function(root) {
    if(!root) return []
    const q = [[root, 0]]
    const res = []
    while(q.length){
        const [n, l] = q.shift()
        if(!res[l]){
            res.push([n.val])
        }else{
            res[l].push(n.val)
        }
        if(n.left) q.push([n.left, l + 1])
        if(n.right) q.push([n.right, l + 1])
    }
    return res
};

//方式2
var levelOrder = function(root) {
    if(!root) return []
    const q = [root]
    const res = []
    while(q.length){
        let len = q.length
        res.push([])
        while(len--){
            const n = q.shift()
            res[res.length - 1].push(n.val)
            if(n.left) q.push(n.left)
            if(n.right) q.push(n.right)
        }
    }
    return res
};
~~~



LeetCode示例: 第94题

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
//递归版
var inorderTraversal = function(root) {
    const res = []
    const rec = (n) => {
        if(!n)return
        rec(n.left)
        res.push(n.val)
        rec(n.right)
    }
    rec(root)
    return res
};
//迭代版
var inorderTraversal = function(root) {
    const res = []
    const stack = []
    let p = root
    while(stack.length || p){
        while(p){
        stack.push(p)
        p = p.left
        }
        const n = stack.pop()
        res.push(n.val)
        p = n.right
    }
    return res
};
~~~

LeetCode示例: 第112题

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(!root)return false
    let res = false
    const dfs = (n,s) => {
        if(!n.left && !n.right && s === sum){
            res = true
        }
        if(n.left) dfs(n.left, s + n.left.val)
        if(n.right) dfs(n.right, s + n.right.val)
    }
    dfs(root, root.val)
    return res
};
~~~

遍历json数据

~~~js
const json = {
    a: {
        b: {
            c: 1
        }
    },
    d: [1,2]
}

const dfs = (n, path) => {
    console.log(n, path)
    Object.keys(n).forEach(k => {
        dfs(n[k])
    })
}
dfs(json, [])
~~~



## 图

图是网络结构的抽象模型, 是一组由边连接的节点

图可以表示任何二元关系, 比如道路, 航班

JS中可以使用Object和Array构建图

图的表示法: 邻接矩阵, 邻接表, 关联矩阵

实操:

~~~js
const graph = {
    0: [1,2],
    1: [2],
    2: [0,3],
    3: [3]
}
//深度优先遍历
const visited1 = new Set()
const dfs1 = (n) => {
    console.log(n)
    visited1.add(n)
    graph[n].forEach(c => {
       if(!visited1.has(c)){
           dfs1(c)
       }
    })
}
dfs1(2)
//广度优先遍历
const visited2 = new Set()
visited2.add(2)
const q = [2]
while (q.length){
    const n = q.shift()
    console.log(n)
    graph[n].forEach(c => {
        if(!visited2.has(c)){
            q.push(c)
            visited2.add(c)
        }
    })
}
~~~



LeetCode示例: 第65题

~~~js
/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function(s) {
    const graph = {
        0: {'blank': 0, 'sign': 1, '.': 2, 'digit': 6},
        1: {'digit': 6, '.': 2},
        2: {'digit': 3},
        3: {'digit': 3, 'e': 4},
        4: {'digit': 5, 'sign': 7},
        5: {'digit': 5},
        6: {'digit': 6, '.': 3, 'e': 4},
        7: {'digit': 5}
    }
    let state = 0
    for(c of s.trim()){
        if(c >= '0' && c <= '9'){
            c = 'digit'
        } else if (c === ' ') {
            c = 'blank'
        } else if (c === '+' || c === '-') {
            c = 'sign'
        }
        state = graph[state][c]
        if(state === undefined){
            return false
        }
    }
    if(state === 3 || state === 5 || state ===6){
        return true
    }
    return false
};
~~~



LeetCode示例: 第417题

~~~js
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var pacificAtlantic = function(matrix) {
    if(!matrix || !matrix[0]){return []}
    const m = matrix.length
    const n = matrix[0].length
    const flow1 = Array.from({length: m}, () => new Array(n).fill(false))
    const flow2 = Array.from({length: m}, () => new Array(n).fill(false))
    const dfs = (r,c,flow) => {
        flow[r][c] = true;
        [[r-1, c], [r+1, c], [r, c-1], [r, c+1]].forEach(([nr, nc])=>{
            if(
                nr >= 0 && nr < m &&
                nc >= 0 && nc < n &&
                !flow[nr][nc] &&
                matrix[nr][nc] >= matrix[r][c]
            ){
                dfs(nr, nc, flow)
            }
        })
    }
    for(let r = 0; r<m; r++){
        dfs(r, 0, flow1)
        dfs(r, n-1, flow2)
    }
    for(let c=0; c<n; c++){
        dfs(0, c, flow1)
        dfs(m-1, c, flow2)
    }
    const res = []
    for(let r = 0; r<m; r++){
        for(let c = 0; c<n; c++){
            if(flow1[r][c] && flow2[r][c]){
                res.push([r,c])
            }
        }
    }
    return res
};
~~~

LeetCode示例: 第133题

~~~js
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
    if(!node) return
    const visited = new Map()
    const dfs = (n) => {
        const nCopy = new Node(n.val)
        visited.set(n, nCopy);
        (n.neighbors || []).forEach(ne => {
            if(!visited.has(ne)){
                dfs(ne)
            }
            nCopy.neighbors.push(visited.get(ne))
        })
    }
    dfs(node)
    return visited.get(node)
};
~~~



## 堆

堆是一种特殊的完全二叉树

所有的节点都大于等于 ( 最大堆 ) 或小于等于 ( 最小堆 ) 它的子节点

实操:

~~~js
class MinHeep {
    constructor() {
        this.heap = []
    }
    swap(i1, i2){
        const temp = this.heap[i1]
        this.heap[i1] = this.heap[i2]
        this.heap[i2] = temp
    }
    getParentIndex(i){
        return (i - 1) >> 1
    }
    getLeftIndex(i){
        return i * 2 + 1
    }
    getRightIndex(i){
        return i * 2 + 2
    }
    shiftUp(index){
        if (index === 0) { return }
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex] > this.heap[index]){
            this.swap(parentIndex, index)
            this.shiftUp(parentIndex)
        }
    }
    shiftDown(index){
        const leftIndex = this.getLeftIndex(index)
        const rightIndex = this.getRightIndex(index)
        if (this.heap[leftIndex] < this.heap[index]){
            this.swap(leftIndex, index)
            this.shiftDown(leftIndex)
        }
        if (this.heap[rightIndex] < this.heap[index]){
            this.swap(rightIndex, index)
            this.shiftDown(rightIndex)
        }
    }
    insert(value){
        this.heap.push(value)
        this.shiftUp(this.heap.length - 1)
    }
    pop(){
        this.heap[0] = this.heap.pop()
        this.shiftDown(0)
    }
    peek(){
        return this.heap[0]
    }
    size(){
        return this.heap.length
    }
}
const h = new MinHeep()
h.insert(3)
h.insert(2)
h.insert(1)
h.pop()
~~~

LeetCode示例: 第215题

~~~js
class MinHeep {
    constructor() {
        this.heap = []
    }
    swap(i1, i2){
        const temp = this.heap[i1]
        this.heap[i1] = this.heap[i2]
        this.heap[i2] = temp
    }
    getParentIndex(i){
        return (i - 1) >> 1
    }
    getLeftIndex(i){
        return i * 2 + 1
    }
    getRightIndex(i){
        return i * 2 + 2
    }
    shiftUp(index){
        if (index === 0) { return }
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex] > this.heap[index]){
            this.swap(parentIndex, index)
            this.shiftUp(parentIndex)
        }
    }
    shiftDown(index){
        const leftIndex = this.getLeftIndex(index)
        const rightIndex = this.getRightIndex(index)
        if (this.heap[leftIndex] < this.heap[index]){
            this.swap(leftIndex, index)
            this.shiftDown(leftIndex)
        }
        if (this.heap[rightIndex] < this.heap[index]){
            this.swap(rightIndex, index)
            this.shiftDown(rightIndex)
        }
    }
    insert(value){
        this.heap.push(value)
        this.shiftUp(this.heap.length - 1)
    }
    pop(){
        this.heap[0] = this.heap.pop()
        this.shiftDown(0)
    }
    peek(){
        return this.heap[0]
    }
    size(){
        return this.heap.length
    }
}
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    const h = new MinHeep()
    nums.forEach(n => {
        h.insert(n)
        if(h.size() > k){
            h.pop()
        }
    })
    return h.peek()
};
~~~

LeetCode示例: 第347题

~~~js
class MinHeep {
    constructor() {
        this.heap = []
    }
    swap(i1, i2){
        const temp = this.heap[i1]
        this.heap[i1] = this.heap[i2]
        this.heap[i2] = temp
    }
    getParentIndex(i){
        return (i - 1) >> 1
    }
    getLeftIndex(i){
        return i * 2 + 1
    }
    getRightIndex(i){
        return i * 2 + 2
    }
    shiftUp(index){
        if (index === 0) { return }
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex] && this.heap[parentIndex].value > this.heap[index].value){
            this.swap(parentIndex, index)
            this.shiftUp(parentIndex)
        }
    }
    shiftDown(index){
        const leftIndex = this.getLeftIndex(index)
        const rightIndex = this.getRightIndex(index)
        if (this.heap[leftIndex] && this.heap[leftIndex].value < this.heap[index].value){
            this.swap(leftIndex, index)
            this.shiftDown(leftIndex)
        }
        if (this.heap[rightIndex] && this.heap[rightIndex].value < this.heap[index].value){
            this.swap(rightIndex, index)
            this.shiftDown(rightIndex)
        }
    }
    insert(value){
        this.heap.push(value)
        this.shiftUp(this.heap.length - 1)
    }
    pop(){
        this.heap[0] = this.heap.pop()
        this.shiftDown(0)
    }
    peek(){
        return this.heap[0]
    }
    size(){
        return this.heap.length
    }
}
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    const map = new Map()
    nums.forEach(n => {
        map.set(n, map.has(n) ? map.get(n) + 1 : 1)
    })
    const h = new MinHeep()
    map.forEach((value, key) => {
        h.insert({value, key})
        if(h.size() > k){
            h.pop()
        }
    })
    return h.heap.map(a => a.key)
};
~~~

LeetCode示例: 第23题

~~~js
class MinHeep {
    constructor() {
        this.heap = []
    }
    swap(i1, i2){
        const temp = this.heap[i1]
        this.heap[i1] = this.heap[i2]
        this.heap[i2] = temp
    }
    getParentIndex(i){
        return (i - 1) >> 1
    }
    getLeftIndex(i){
        return i * 2 + 1
    }
    getRightIndex(i){
        return i * 2 + 2
    }
    shiftUp(index){
        if (index === 0) { return }
        const parentIndex = this.getParentIndex(index)
        if(this.heap[parentIndex] && this.heap[parentIndex].val > this.heap[index].val){
            this.swap(parentIndex, index)
            this.shiftUp(parentIndex)
        }
    }
    shiftDown(index){
        const leftIndex = this.getLeftIndex(index)
        const rightIndex = this.getRightIndex(index)
        if (this.heap[leftIndex] && this.heap[leftIndex].val < this.heap[index].val){
            this.swap(leftIndex, index)
            this.shiftDown(leftIndex)
        }
        if (this.heap[rightIndex] && this.heap[rightIndex].val < this.heap[index].val){
            this.swap(rightIndex, index)
            this.shiftDown(rightIndex)
        }
    }
    insert(value){
        this.heap.push(value)
        this.shiftUp(this.heap.length - 1)
    }
    pop(){
        if(this.size() === 1) return this.heap.shift()
        const top = this.heap[0]
        this.heap[0] = this.heap.pop()
        this.shiftDown(0)
        return top
    }
    peek(){
        return this.heap[0]
    }
    size(){
        return this.heap.length
    }
}
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    const res = new ListNode(0)
    let p = res
    const h = new MinHeep()
    lists.forEach(l => {
        if(l) h.insert(l)
    })
    while(h.size()){
        const n = h.pop()
        p.next = n
        p = p.next
        if(n.next) h.insert(n.next)
    }
    return res.next
};

~~~



## 排序

冒泡排序:

~~~js
Array.prototype.bubbleSort = function () {
    for (let i = 0; i < this.length -1; i++){
        for (let j = 0; j < this.length - 1 - i; j++){
            if (this[j] > this[j+1]){
                const temp = this[j]
                this[j] = this[j + 1]
                this[j + 1] = temp
            }
        }
    }
}
const arr = [5,4,3,2,1]
arr.bubbleSort()
console.log(arr)
~~~

选择排序:

~~~js
Array.prototype.selectSort = function () {
    for (let i = 0; i < this.length - 1; i++) {
        let indexMin = i
        for (let j = i; j < this.length; j++){
            if (this[j] < this[indexMin]){
                indexMin = j
            }
        }
        if (indexMin !== i) {
            const temp = this[i]
            this[i] = this[indexMin]
            this[indexMin] = temp
        }
    }
}
const arr = [5,4,3,2,1]
arr.selectSort()
console.log(arr)
~~~

插入排序:

~~~js
Array.prototype.insertionSort = function () {
    for (let i = 0; i < this.length; i++) {
        const temp = this[i]
        let j = i
        while (j > 0) {
            if (this[j - 1] > temp) {
                this[j] = this[j - 1]
            }else {
                break;
            }
            j -= 1
        }
        this[j] = temp
    }
}
const arr = [5,4,3,2,1]
arr.insertionSort()
console.log(arr)
~~~

归并排序:

~~~js
Array.prototype.mergeSort = function () {
    const rec = (arr) => {
        if (arr.length === 1) { return  arr }
        const mid = Math.floor(arr.length / 2)
        const left = arr.slice(0, mid)
        const right = arr.slice(mid, arr.length)
        const orderLeft = rec(left)
        const orderRight = rec(right)
        const res = []
        while (orderLeft.length || orderRight.length) {
            if (orderLeft.length && orderRight.length) {
                res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())
            }else if (orderLeft.length) {
                res.push(orderLeft.shift())
            }else if (orderRight.length) {
                res.push(orderRight.shift())
            }
        }
        return res
    }
    const res = rec(this)
    res.forEach((n, i) => { this[i] = n })
}
const arr = [5,4,3,2,1]
arr.mergeSort()
console.log(arr)
~~~

快速排序:

~~~js
Array.prototype.quickSort = function () {
    const rec = (arr) => {
        if (arr.length === 1) { return arr; }
        const left = []
        const right = []
        const mid = arr[0]
        for (let i = 1; i < arr.length; i++){
            if (arr[i] < mid){
                left.push(arr[i])
            }else {
                right.push(arr[i])
            }
        }
        return [...rec(left), mid, ...rec(right)]
    };
    const res = rec(this);
    res.forEach((n, i) => {
        this[i] = n
    })
}
const arr = [2,4,3,5,1]
arr.quickSort()
console.log(arr)
~~~

LeetCode示例: 第21题

~~~js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    let res = new ListNode(0)
    let p = res
    let p1 = l1
    let p2 = l2
    while(p1&&p2){
        if(p1.val < p2.val){
            p.next = p1
            p1 = p1.next
        }else{
            p.next = p2
            p2 = p2.next
        }
        p = p.next
    }
    if(p1){
        p.next = p1
    }
    if(p2){
        p.next = p2
    }
    return res.next
};
~~~



## 搜索

顺序搜索:

~~~js
Array.prototype.sequentialSearch = function (item) {
    for (let i = 0; i < this.length; i++){
        if (this[i] === item) {
            return i
        }
    }
    return -1
}
const arr = [5,4,3,2,1].sequentialSearch(3)
console.log(arr)
~~~

二分搜索:

~~~js
Array.prototype.binarySearch = function (item) {
    let low = 0
    let high = this.length - 1
    while (low <= high){
        const mid = Math.floor((low + high) / 2)
        const element = this[mid]
        if (element < item){
            low = mid + 1
        }else if (element > item){
            high = mid - 1
        }else {
            return mid
        }
    }
    return -1
}
const arr = [5,4,3,2,1].binarySearch(3)
console.log(arr)
~~~



LeetCode示例: 第374题

~~~js
/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return 	            -1 if num is lower than the guess number
 *			             1 if num is higher than the guess number
 *                       otherwise return 0
 * var guess = function(num) {}
 */

/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    let low = 1
    let high = n
    while(low <= high){
        const mid = Math.floor((low + high) / 2)
        const res = guess(mid)
        if(res === 0){
            return mid
        }else if(res === 1){
            low = mid + 1
        }else{
            high = mid - 1
        }
    }
};
~~~



# 算法

## 分而治之

算法设计中的一种思想方法

它将一个问题分成多个和原问题相似的小问题, 递归解决小问题, 再将结果合并以解决原理的问题

场景一: 归并排序

- 分: 把数组从中间一份为二
- 解: 递归的对两个子数组进行归并排序
- 合: 合并有序子数组

场景二: 快速排序

- 分: 选基准, 按基准把数组分成两个子数组
- 解: 递归的对两个子数组进行快速排序
- 合: 对两个子数组进行合并

LeetCode示例: 第226题

- 分: 获取左右子树
- 解: 递归的翻转左右子树
- 合: 将翻转后的左右子树换个位置放到根节点上

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root){return null;}
    return {
        val: root.val,
        left: invertTree(root.right),
        right: invertTree(root.left)
    }
};
~~~

LeetCode示例: 第100题

- 分: 获取两个树的左右子树
- 解: 递归的判断两个树的左子树是否相同, 右子树是否相同
- 合: 将上述结果合并, 如果根节点的值也相同, 树就相同

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(!p && !q) return true;
    if(p && q && p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)){
        return true
    }
    return false
};
~~~

LeetCode示例: 第101题

- 分: 获取两个树的左右子树
- 解: 递归的判断树1的左子树和树2的右子树是否镜像, 树1的右子树和树2的左子树是否镜像
- 合: 如果上述都成立, 且根节点值也相同, 两树就镜像

~~~js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if(!root) return true;
    const isMirror = (l,r) =>{
        if(!l && !r) return true
        if(l && r && l.val === r.val && isMirror(l.left, r.right) && isMirror(l.right, r.left)){
            return true
        }
        return false
    }
    return isMirror(root.left, root.right)
};
~~~



## 动态规划

算法设计中的一种思想方法

它将一个问题分解为互相重叠的子问题, 通过反复求解子问题来解决问题

LeetCode示例: 第70题 ( 同斐波那契数列 )

- 定义子问题: F(n) = F(n-1) + F(n-2)
- 反复执行: 从2循环到n, 执行上述公式

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n < 2) return 1
    const dp = [1, 1]
    for(let i = 2; i <= n; i++){
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
};

//优化
var climbStairs = function(n) {
    if(n < 2) return 1
    let dp0 = 1
    let dp1 = 1
    for(let i = 2; i <= n; i++){
        const temp = dp0
        dp0 = dp1
        dp1 = dp1 + temp
    }
    return dp1
};
~~~



LeetCode示例: 第198题

- f(k) = 从前k个房屋中能偷窃到的最大数额
- Ak = 第k个房屋的钱数
- 定义子问题: f(k) = max(f(k - 2) + Ak, f(k - 1))
- 反复执行: 从2循环到n, 执行上述公式

~~~js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if (nums.length === 0) { return 0 }
    const dp = [0, nums[0]]
    for(let i = 2; i <= nums.length; i++){
        dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i-1])
    }
    return dp[nums.length]
};
//优化
var rob = function(nums) {
    if (nums.length === 0) { return 0 }
    let dp0 = 0
    let dp1 = nums[0]
    for(let i = 2; i <= nums.length; i++){
        const dp2 = Math.max(dp0 + nums[i-1], dp1)
        dp0 = dp1
        dp1 = dp2
    }
    return dp1
};
~~~



## 贪心算法

算法设计中的一种思想方法

期盼通过每个阶段的局部最优选择, 从而达到全局的最优

结果并不一定是最优

LeetCode示例: 第455题

- 局部最优: 既能满足孩子, 还消耗最少
- 先将较小的饼干分给胃口最小的孩子
- 对饼干数组和胃口数组升序排序
- 遍历饼干数组, 找到能满足第一个孩子的饼干
- 然后继续遍历饼干数组, 找到满足第二,三,...,n个孩子的饼干

~~~js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    const sortFunc = function (a, b){
        return a - b
    }
    g.sort(sortFunc)
    s.sort(sortFunc)
    let i = 0
    s.forEach(n => {
        if(n>=g[i]){
            i += 1
        }
    })
    return i
};
~~~



LeetCode示例: 第122题

- 前提: 上帝视角, 知道未来价格
- 局部最优: 见好就收, 见差就不动, 不做任何长远打算
- 新建变量, 用来统计总利润
- 遍历价格数组, 如果当前价格比昨天高, 就在昨天买, 今天卖, 否则就不交易

~~~js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let profit = 0
    for(let i = 1; i < prices.length; i++){
        if(prices[i] > prices[i - 1]) {
            profit += prices[i] - prices[i - 1] 
        }
    }
    return profit
};
~~~



## 回溯算法

算法设计中的一种思想方法

回溯算法是一种渐进式寻找并构建问题解决方式的策略

回溯算法会先从一个可能的动作开始解决问题, 如果不行,就回溯并选择另一个动作, 直到将问题解决

LeetCode示例: 第46题

- 用递归模拟出所有情况
- 遇到包含重复元素的情况, 就回溯
- 收集所有到达递归终点的情况, 并返回

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const res = []
    const backtrack = (path) => {
        if(path.length === nums.length){
            res.push(path)
            return
        }
        nums.forEach(n => {
            if(path.includes(n)) { return }
            backtrack(path.concat(n))
        })
    }
    backtrack([])
    return res
};
~~~



LeetCode示例: 第78题

- 用递归模拟出所有情况
- 保证接的数字都是后面的数字
- 收集所有到达递归终点的情况, 并返回

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const res = []
    const backtrack = (path, l, start) => {
        if (path.length === l){
            res.push(path)
            return
        }
        for(let i = start; i < nums.length; i++){
            backtrack(path.concat(nums[i]), l, i+1)
        }
    }
    for(let i = 0; i <=nums.length; i++){
        backtrack([], i, 0)
    }
    return res
};
~~~



# 前端进阶

## 依赖升级

- 使用vue cli的vue upgrade命令升级官方插件
- 使用prettier + prettier-eslint ( vetur ) 格式化代码
- husky + lint-staged把关代码质量

步骤:

​	yarn	//安装依赖

​	vue upgrade	//更新依赖

​	ERROR  Cannot find file babel.config.js	//babel报错删除依赖包

​	yarn	//重新安装依赖

​	vue upgrade	//再次更新依赖

​	yarn dev	//启动项目

​	ERROR  Invalid options in vue.config.js: "baseUrl" is not allowed	//vue配置文件报错

​	将baseURL改成publicPath

​	yarn lint	//执行es-lint检查, 手动修复重新启动项目

​	yarn add prettier-eslint -D	//全局安装

​	创建.prettierrc配置文件: 执行yarn lint会按照配置项对整个项目格式化

~~~json
{
  "tabWidth": 2,
  "useTabs": false,
  "semi": false,
  "singleQuote": true
}
~~~

yarn add lint-staged husky -D	//git命令前的es-lint检查工具

配置package.json:

~~~json
"husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.js": [
      "vue-cli-service lint",
      "git add"
    ],
    "*.vue": [
      "vue-cli-service lint",
      "git add"
    ]
  }
~~~

git init 	//初始化git仓库

yarn add husky -D	//重新安装husky

git add .	//保存到本地仓库

git commit -m "first commit, 更新依赖" --no-verify	//初始化commit提交

npm install -g npm-check-updates	//安装node工具管理依赖包版本

ncu	//检查依赖包版本

ncu -u	//更新版本号

yarn	//删除node_modules重新安装依赖



## VUE源码

### snabbdom

著名的虚拟dom库, diff算法的鼻祖, vue源码借鉴了snabbdom

  

### h函数

用来生成虚拟节点( vnode )

可嵌套, 一个子元素可以直接当参数传入, 多个需要用数组包裹

~~~js
h('a', { props: { href: 'http://www.baidu.com' } }, '高江华')
//生成的虚拟节点
{
  "sel": "a",
  "data": { props: { href: 'http://www.baidu.com' } },
  "text": "高江华"
}
//真实的DOM节点
<a href="http://www.baidu.com">高江华</a>
~~~

示例 ( 基于snabbdom ) :

~~~js
//创建patch函数
const patch = init([classModule, propsModule, styleModule, eventListenersModule])
//创建虚拟节点
const myVnode = h('a', { props: { href: 'http://www.baidu.com } }, '高江华')
//让虚拟节点上树
const container = document.getElementById('container')
patch(container, myVnode)
~~~



简易版手写虚拟DOM:

~~~js
function vnode(sel, data, children, text, elm) {
  return {
    sel, data, children, text, elm
  }
}
function h(sel, data, c) {
  if (arguments.length !== 3){
    throw new Error('必须传入3个参数')
  }
  if (typeof c == 'string' || typeof c == 'number'){
    return vnode(sel, data, undefined, c, undefined)
  }else if (Array.isArray(c)){
    let children = []
    for (let i = 0; i < c.length; i++){
      if (!(typeof c[i] == 'object' && c[i].hasOwnProperty('sel')))
        throw new Error('传入的数组参数中有项不是h函数')
      children.push(c[i])
    }
    return vnode(sel, data, children, undefined, undefined)
  }else if (typeof c == 'object' && c.hasOwnProperty('sel')){
    let children = [c]
    return vnode(sel, data, children, undefined, undefined)
  }else {
    throw new Error('传入的第三个参数不对')
  }
}
let myVnode = h('div', {}, [
  h('ul', {}, [
    h('li', {}, '苹果'),
    h('li', {}, '香蕉'),
    h('li', {}, '桔子'),
    h('li', {}, [
      h('p', {}, '123'),
      h('p', {}, '456')
    ]),
  ])
])
console.log(myVnode)
~~~



###  DIFF算法

- 最小量更新, key很重要, key是这个节点的唯一标识, 告诉diff算法, 在更改前后它们是同一个DOM节点

- 只有是同一个虚拟节点,才进行精细化比较, 否则暴力删旧插新

- 选择器相同且key相同就是同一虚拟节点

- 只进行同层比较, 不会进行跨层比较, 即使同一虚拟节点,但是跨层了也不会精细化比较, 只会删旧插新

- 四种命中查找: 设置四个指针 ( 新前 旧前 新后 旧后 )

  1. 新前与旧前
  2. 新后与旧后
  3. 新后与旧前 ( 此种发生了, 涉及移动节点, 那么新前指向的节点, 移动到旧后之后 )
  4. 新前与旧后 ( 此种发生了, 涉及移动节点, 那么新前指向的节点, 移动到旧前之前 )

  注: 命中一种就不再进行命中判断, 若没命中则继续顺序使用命中判断, 若都未命中则循环旧子节点查找有没有对应的新子节点



![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210105173343133.png)

精细化比较如下:

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210107111327461.png)



简易版diff算法:

~~~js
function vnode(sel, data, children, text, elm) {
  const key = data.key
  return {
    sel, data, children, text, elm, key
  }
}
function h(sel, data, c) {
  if (arguments.length !== 3){
    throw new Error('必须传入3个参数')
  }
  if (typeof c == 'string' || typeof c == 'number'){
    return vnode(sel, data, undefined, c, undefined)
  }else if (Array.isArray(c)){
    let children = []
    for (let i = 0; i < c.length; i++){
      if (!(typeof c[i] == 'object' && c[i].hasOwnProperty('sel')))
        throw new Error('传入的数组参数中有项不是h函数')
      children.push(c[i])
    }
    return vnode(sel, data, children, undefined, undefined)
  }else if (typeof c == 'object' && c.hasOwnProperty('sel')){
    let children = [c]
    return vnode(sel, data, children, undefined, undefined)
  }else {
    throw new Error('传入的第三个参数不对')
  }
}
function createElement(vnode) {
  let domNode = document.createElement(vnode.sel)
  if (vnode.text != '' && (vnode.children == undefined || vnode.children.length == 0)){
    domNode.innerText = vnode.text
    vnode.elm = domNode
  }else if (Array.isArray(vnode.children) && vnode.children.length > 0){
    for (let i = 0; i < vnode.children.length; i++){
      let ch = vnode.children[i]
      let chdom = createElement(ch)
      domNode.appendChild(chdom)
    }
  }
  vnode.elm = domNode
  return vnode.elm
}
function checkSameVnode(a, b) {
  return a.sel == b.sel && a.key == b.key
}
function updateChildren(parentElm, oldCh, newCh){
  //旧前
  let oldStartIdx = 0
  //新前
  let newStartIdx = 0
  //旧后
  let oldEndIdx = oldCh.length - 1
  //新后
  let newEndIdx = newCh.length - 1
  //旧前节点
  let oldStartVnode = oldCh[0]
  //旧后节点
  let oldEndVnode = oldCh[oldEndIdx]
  //新前节点
  let newStartVnode = newCh[0]
  //新后节点
  let newEndVnode = newCh[newEndIdx]
  //标杆
  let keyMap = null
  //循环精细化比较开始
  while (oldStartIdx <= oldEndIdx && newSrartIdx <= newEndIdx) {
    if (oldStartVnode === null || oldCh[oldStartIdx] === undefined){
      oldStartVnode = oldCh[++oldStartIdx]
    }else if (oldEndVnode === null || oldCh[oldEndIdx] === undefined){
      oldEndVnode = oldCh[--oldEndIdx]
    }else if (newStartVnode === null || newCh[newStartIdx] === undefined){
      newStartVnode = newCh[++newStartIdx]
    }else if (newEndVnode === null || newCh[newEndIdx] === undefined){
      newEndVnode = newCh[--newEndIdx]
    }else if (checkSameVnode(oldStartVnode, newSrartIdx)){
      patchVnode(oldStartVnode, newStartVnode)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newSrartIdx]
    }else if (checkSameVnode(oldEndVnode,newEndVnode)){
      patchVnode(oldEndVnode, newEndVnode)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    }else if (checkSameVnode(oldStartVnode,newEndVnode)){
      patchVnode(oldStartVnode, newEndVnode)
      parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling())
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    }else if (checkSameVnode(oldEndVnode,newStartVnode)){
      patchVnode(oldEndVnode,newStartVnode)
      parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm.nextSibling())
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    }else {
      //四种命中都未命中,则制作keyMap映射对象
      keyMap = {}
      if (!keyMap){
        //从oldStartIdx开始, 到oldEndIdx结束, 创建keyMap映射对象
        for (let i = oldStartIdx; i <= oldEndIdx; i++){
          const key = oldCh[i].key
          if (key !== undefined){
            keyMap[key] = i
          }
        }
      }
      const idxInOld = keyMap[newStartVnode.key]
      if (idxInOld === undefined){
        //是全新的项, 被加入的项(就是newStartVnode)现不是真正的DOM节点
        parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm)
      }else {
        //不是全新的项,需要移动
        const elmToMove = oldCh[idxInOld]
        patchVnode(elmToMove, newStartVnode)
        oldCh[idxInOld] = undefined
        parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm)
      }
      newStartVnode = newCh[++newStartIdx]
    }
  }
  //判断还有没有剩余的,start比end小
  if (newStartIdx <= newEndIdx){
    //new还有剩余节点没处理
    //const before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm
    for (let i = newStartIdx; i <= newEndIdx; i++){
      //insertBefore方法可以自动识别null, 如果是null就会自动排到队尾去, 和appendChild是一致的
      parentElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm)
    }
  }else if (oldStartIdx <= oldEndIdx){
    //old还有剩余节点没处理
    for (let i = oldStartIdx; i <= oldEndIdx; i++){
      if (oldCh[i]){
        parentElm.removeChild(oldCh[i].elm)
      }
    }
  }
}
function patchVnode(oldVnode, newVnode) {
  if (oldVnode === newVnode) return ;
  if (newVnode.text != undefined && newVnode.children == undefined || newVnode.children.length == 0){
    if (newVnode.text != oldVnode.text){
      oldVnode.elm.innerText = newVnode.text
    }
  }else {
    if (oldVnode.children != undefined && oldVnode.children.length > 0){
      updateChildren(oldVnode.elm, oldVnode.children, newVnode.children)
    }else {
      oldVnode.elm.innerText = ''
      for (let i = 0; i < newVnode.children.length; i++){
        let dom = createElement(newVnode.children[i])
        oldVnode.elm.appendChild(dom)
      }
    }
  }
}
function patch(oldVnode, newVnode){
  if (oldVnode.sel == '' || oldVnode.sel == undefined){
    oldVnode = vnode(oldVnode.tagName.toLowerCase(), {}, [], undefined, oldVnode)
  }
  if (oldVnode.key == newVnode.key && oldVnode.sel == oldVnode.sel){
    patchVnode(oldVnode, newVnode)
  }else {
    let newVnodeElm = createElement(newVnode)
    if (oldVnode.elm && newVnodeElm) {
      oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm)
    }
    oldVnode.elm.parentNode.removeChild(oldVnode.elm)
  }
}
let myVnode1 = h('ul', {}, [
  h('li', {key: 'A'}, 'A'),
  h('li', {key: 'B'}, 'B'),
  h('li', {key: 'C'}, 'C'),
  h('li', {key: 'D'}, 'D'),
  h('li', {key: 'E'}, 'E'),
])
const container = document.getElementById('container')
const btn = document.getElementById('btn')
patch(container, myVnode1)
const myVnode2 = h('ul', {}, [
  h('li', {key: 'A'}, 'A'),
  h('li', {key: 'B'}, 'B'),
  h('li', {key: 'C'}, 'C'),
  h('li', {key: 'D'}, 'D'),
  h('li', {key: 'E'}, 'E'),
  h('li', {key: 'F'}, 'F'),
  h('li', {key: 'G'}, 'G'),
])
btn.onclick = function(){
  patch(myVnode1, myVnode2)
}
~~~



# PM2

 pm2需要全局安装

 `npm install -g pm2`

### 进入项目根目录:

启动进程/应用           `pm2 start bin/www 或 pm2 start app.js`

重命名进程/应用           `pm2 start app.js --name wb123`

添加进程/应用 watch         `pm2 start bin/www --watch`

结束进程/应用            `pm2 stop www`

结束所有进程/应用           `pm2 stop all`

删除进程/应用            `pm2 delete www`

删除所有进程/应用             `pm2 delete all`

列出所有进程/应用          `pm2 list`

查看某个进程/应用具体情况      `pm2 describe www`

查看进程/应用的资源消耗情况       `pm2 monit`

查看pm2的日志                 `pm2 logs`

若要查看某个进程/应用的日志,使用  `pm2 logs www`

重新启动进程/应用            `pm2 restart www`

重新启动所有进程/应用        `pm2 restart all`



### 参数说明：

- `--watch`：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。
- `-i --instances`：启用多少个实例，可用于负载均衡。如果`-i 0`或者`-i max`，则根据当前机器核数确定实例数目。
- `--ignore-watch`：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如`--ignore-watch="test node_modules "some scripts""`
- `-n --name`：应用的名称。查看应用信息的时候可以用到。
- `-o --output `：标准输出日志文件的路径。
- `-e --error `：错误输出日志文件的路径。
- `--interpreter `：the interpreter pm2 should use for executing app (bash, python...)。比如你用的coffee script来编写应用。



# React

jsx语法:	

~~javascrpt + xml(html)

解读jsx语法:	

~~遇到<>按xml(html) 语法解析, 遇到{}按javascript语法解析

父传子: 

~~父组件中的子组件标签<Mycom nav={array}>, 子组件中通过this.props.nav获取

~~通过props获取的父组件的值在子组件中是只读的,不可更改

子传父:

~~子组件: 

~~~jsx
clickChange = () =>{ this.props.clickChanges('子组件数据') }
render(){
    return(
        <div>
            <button onClick={ this.clickChange }>修改</button>
        <div>
	)
}
~~~

~~父组件:

~~~jsx
clickChange = (data) =>{ 
    this.setState({
		count: data										//子组件数据
    }) 
}
render(){   
    return(
        <div>
            <Component clickChanges={ this.clickChange }>   //子组件标签
        <div>
	)
}

~~~

state状态: 

~~通过this.state = { count : 0 } 来设置

~~通过this.setState({ count : this.state.count +=1 }) 来更改

~~this.setState()本身为异步修改, 可以通过第二个参数callback回调函数同步获取值

~~封装this.setState()为同步修改:

~~~js
increment = async () => {
	await this.setStateAsync({ count : this.state.count +=1 })
	console.log(this.state.count)
}
setStateAsync(state){
	return new Promise((resolve)=>{
		this.setState(state,resolve)
	})
}
~~~

生命周期:

~~componentWillMount: 在组件渲染之前执行

~~componentDidMount: 在组件渲染之后执行

~~shouldComponentUpdate: 返回true和false, true允许执行, false不允许执行

~~componentUpdate: 数据在改变之前执行 (即state, props被修改)

~~componentDidUpdate: 数据在改变完成之后执行 (即state, props被修改)

~~componentWillReveiceProps: props发送改变执行

~~componentWillUnmount: 组件卸载前执行

~~componentDidCatch:子元素发送错误时触发

循环中的Key的作用:

~~如果数据索引没有发生变化则不会重绘, 只有发生变化的索引才会重绘

通过refs获取DOM节点:

~~~jsx
constructor(){
    super()
    this.Hello = React.createRef()
}
componentDidMount(){ this.Hello.current.style.color = "red" }
render(){
    return(
        <div>
            <div ref={ this.Hello }>hello</div>
        <div>
	)
}
~~~

受控组件:

~~~jsx
constructor(){
    super()
    this.state = {
    	value:''
    }
}
inputChange = (e) => { 
    this.setState({
		value:e.target.value
    })
    console.log( this.state.value )
}
render(){
    return(
        <div>
            <input onChange={ this.inputChange }/>
        <div>
	)
}
~~~

非受控组件:

~~~jsx
constructor(){
    super()
    this.username = React.createRef()
}
clickButton = (e) => { 
    console.log( this.username.current.value )
}
render(){
    return(
        <div>
            <input ref={ this.username }/>
            <button onClick={ this.clickButton }></button>
        <div>
	)
}
~~~

  

## Router路由

匹配规则: 

~~exact属性为true时路径中的hash值必须和path完全一致才渲染对应的组件，如果为false则'/'也可以匹配'/xxx';（如果strict属性为false，则末尾是否包含反斜杠结尾不影响匹配结果)

~~strict属性主要就是匹配反斜杠，规定是否匹配末尾包含反斜杠的路径，如果strict为true，则如果path中不包含反斜杠结尾，则他也不能匹配包含反斜杠结尾的路径，这个需要和exact结合使用

Switch标签:

~~有<Switch>标签，则其中的<Route>在路径相同的情况下，只匹配第一个，这个可以避免重复匹配

Link标签:

~~底层就是a标签做了优化封装

NavLink标签:

~~当前选中会添加一个active类, activeClassName用于改变active类名, activeStyle设置选中样式

路由传参:

~~在路由后面加上/:id?

~~?为可选可不选参数, 传多参数就加多个/:id?

~~~jsx
function(){
    return (
        <div>
            <Router>
                <Switch>
                    <Route exact path="/" component={ Home }></Route>
                    <Route strict exact path="/mine" component={ Mine }></Route>
                    <Route strict exact path="/mine/ucenter" component={ UCenter }>							</Route>
                    <Route component={ NotFound }></Route>//不存在的页面
                </Switch>
            </Router>
        </div>
    )
}
//访问路由
<Link to="/"></Link>
<Link to="/mine"></Link>
<Link to="/mine/ucenter"></Link>
<NavLink activeClassName="selected" activeStyle={{ color:'red'}} exact to="/mine/ucenter/:id?">
</NavLink>
~~~

获取路由上的参数:

~~~jsx
import querystring from "querystring"
const Mine = (props) =>{
	const params = new URLSearchParams(props.location.search)
	console.log(params.get("key"))
	const value = querystring.parse(props.loaction.search)
	console.log(value)
}
~~~

to属性:

~~search, hash为路由上的参数, 会在路由链接上显示

~~跳转到指定的pathname才会获取到state里面的值

~~~jsx
<NavLink to={{
        pathname:"/mine",
        search:"?sort=name",
        hash:"#the-hash",
        state:{ flag: true }
    }}>
</NavLink>
~~~

重定向:

~~from是指定前往的路由页面

~~to是重定向后的页面

~~push为新增, 之前的页面不会消失,会留在缓存中

~~replace为替换, 替换之前的页面

~~~jsx
const clickHandle = () =>{
    props.history.push("/")
    props.history.replace("/")
}
<button onClick={ clickHandle }></button>
<Redirect from='/hellomine' to='/mine'></Redirect>
~~~

高阶组件withRouter:

~~可将页面加入到路由管理中, 路由对象便不会为空

~~~jsx
class MineDemo extends React.Component{
	
}
export default withRouter(MineDemo)
~~~

Prompt:

~~用于控制离开页面前的操作未完成的提示

~~~jsx
state = {
    name: ''
}
<Prompt when={ !!this.state.name } message={ '确定要离开该页面吗?' }/>
~~~



## Redux状态管理

注~~redux:JS的状态管理 createStore; ~~react-redux:为了在react中容易使用: connect  provider

安装~~npm install --save-dev redux      npm install --save-dev react-redux

### 单纯使用redux

reducers/counter.js:

~~state就是状态

~~action用于改变状态

~~~jsx
const counter = ( state = 0, action) => {
	switch(action.type){
        case "INCREMENT":
            return state + 1;
        case "DECREMENT":
            return state - 1; 
        default:
            return state
    }
}
export default counter
~~~

入口index.js:

~~getState获取state

~~createStore创建仓库

~~dispatch更新state

~~subscribe监听器

~~~jsx
import React from "react"
import ReactDOM from "react-dom"
import App from "./App"
import { createStore } from "redux"
import reducer from "./reducers/counter"
//创建redux仓库
const store = createStore(reducer)

const render = () =>{
    ReactDOM.render(
    <App
    	onIncreament={ ()=>store.dispatch({ type:"INCREMENT"}) }
        onDecreament={ ()=>store.dispatch({ type:"DECREMENT"}) }
        value={ store.getState() }
    />, 
    document.getElementById('root'))
}
render();
//注册监听器
store.subscribe(render)
~~~

App.js:

~~~jsx
import React from "react"
export default class App extends React.Component {
    render(){
        return (
            <div>
                <h1>{ this.props.value }</h1>
                <p>
                    <button onClick={ this.props.onIncrement} >increment</button>
                    <button onClick={ this.props.onDecrement} >decrement</button>
                </p>
            </div>
        )
    }
}
~~~

### 使用react-redux

reducers/counter.js: 同redux

入口index.js:

~~~jsx
import React from "react"
import ReactDOM from "react-dom"
import App from "./App"
import { createStore } from "redux"
import reducer from "./reducers/counter"
import { Provider } from "react-redux"
//创建redux仓库
const store = createStore(reducer)


ReactDOM.render(
    <Provider store={ store }>
        <App />
    </Provider>
    , 
    document.getElementById('root'))
~~~



App.js:

~~第一种方式

~~~jsx
import React from "react"
import { connect } from "react-redux"
import { increment, decrement } from "./actions/counter"

class App extends React.Component {
    render(){
        const { increment, decrement } = this.props
        return (
            <div>
                <h1>{ this.props.counter }</h1>
                <p>
                    <button onClick={ () => (increment()) } >increment</button>
                    <button onClick={ () => (decrement()) } >decrement</button>
                </p>
            </div>
        )
    }
}
const mapStateToProps = (state) =>{
    return {
    	counter:state
    }
}
const mapDispatchToProps = (dispatch) =>{
    return {
        increment: () => { dispatch(increment()) },
        decrement: () => { dispatch(decrement()) }
    }
}

export default connect(mapStateToProps,mapDispatchToProps)(App)
~~~

~~第二种方式

~~~react
import React from "react"
import { connect } from "react-redux"
import * as counterActions from "./actions/counter"
import { bindActionCreators } from "redux"

class App extends React.Component {
    render(){
        return (
            <div>
                <h1>{ this.props.counter }</h1>
                <p>
                    <button onClick={ () => this.props.counterActions.increment(10) } >increment</button>
                    <button onClick={ () => this.props.counterActions.decrement(20) } >decrement</button>
                </p>
            </div>
        )
    }
}
const mapStateToProps = (state) =>{
    return {
    	counter:state
    }
}
const mapDispatchToProps = (dispatch) =>{
    return {
        counterActions:bindActionCreators(counterActions.dispatch)
    }
}

export default connect(mapStateToProps,mapDispatchToProps)(App)
~~~

actions/counter.js:

~~~js
export function increment(){
	return {
		type:"INCREMENT",
        num
	}
}

export function decrement(){
	return {
		type:"DECREMENT",
        num
	}
}
~~~

### 优化状态

~~新建constants/index.js:

~~~jsx
export const INCREMENT = "INCREMENT"
export const DECREMENT = "DECREMENT"
~~~

reducers/counter.js:

~~~jsx
import * as actions from "../constants"
const counter = ( state = 0, action) => {
	switch(action.type){
        case actions.INCREMENT:
            return state + action.num;
        case actions.DECREMENT:
            return state - action.num; 
        default:
            return state
    }
}
export default counter
~~~

actions/counter.js:

~~~jsx
import * as actions from "../constants"
export function increment(){
	return {
		type:actions.INCREMENT,
        num
	}
}

export function decrement(){
	return {
		type:actions.DECREMENT,
        num
	}
}
~~~

### 多个状态合并

新建reducers/index.js:

~~combineReducers合并方案

~~~jsx
import { combineReducers } from "redux"
import counter from "./counter"

const rootReducer = combineReducers({
    counter
})
export default rootReducer
~~~

入口index.js:

~~~jsx
import React from "react"
import ReactDOM from "react-dom"
import App from "./App"
import { createStore } from "redux"
import rootReducer from "./reducers"
import { Provider } from "react-redux"
//创建redux仓库
const store = createStore(rootReducer)


ReactDOM.render(
    <Provider store={ store }>
        <App />
    </Provider>
    , 
    document.getElementById('root'))
~~~

App.js修改:

~~~jsx
const mapStateToProps = (state) =>{
    return {
    	counter:state.counter
    }
}
~~~

### 新增状态

新建components/user.jsx:

~~~jsx
import React from "react"
export default class User extends React.Component {
	render(){
        return (
            <div>hello</div>
        )
    }
}
~~~

在App.js中新增:

~~~jsx
import User from "./components/user"

<User/>
~~~

在constants/index.js中新增:

~~~JSX
export const ADD_USER = "ADD_USER"
~~~

新增actions/user.js:

~~~jsx
import { ADD_USER } from "../constants"
export function addUser(){
    return {
        type:ADD_USER
    }
}
~~~

新增reducers/user.js:

~~~jsx
import { ADD_USER } from "../constants"
const user = ( state = {}, action ) => {
	switch(action.type){
        case ADD_USER:
            state.push("iwen")
            return state;
        default:
            return state
    }
}
export default user
~~~

reducers/index.js:

~~~jsx
import { combineReducers } from "redux"
import counter from "./counter"
import user from "./user"

const rootReducer = combineReducers({
    counter,
    user
})
export default rootReducer
 
~~~

### 中间件

#### 自定义中间件:

入口index.js新增:

~~applyMiddleware:用于加载中间件

~~~jsx
import { createStore, applyMiddleware } from "redux"

const logger = store => next => action =>{
    console.log("dispatch->", action)
    let result = next(action);  //加载下一个中间件
    console.log("next state->", store.getState())
    return result
}
const error = store => next => action =>{
    try{
    	next(actin)
    }catch(e){
        console.log("error->",e)
    }
}
//创建仓库并加载中间件
const store = createStore(rootReducer, {}, applyMiddleware(logger,error)
~~~

#### 第三方中间件:

~~cnpm install --save-dev redux-logger

入口index.js新增:

~~~jsx
import logger from "redux-logger"

const store = createStore(rootReducer, {}, applyMiddleware(logger)
~~~

##### 处理异步中间件:

~~cnpm install --save-dev redux-thunk

入口index.js新增:

~~~jsx
import thunk from "redux-thunk"

const store = createStore(rootReducer, {}, applyMiddleware(thunk)
~~~

###### 实现定时器异步:

actions/counter.js中:

~~~jsx
export function increment(num){
	return dispatch =>{
		setTimeout(()=>{
			dispatch({
				type:action.INCREMENT,
				num
			})
		})
	}
}
~~~

###### 实现请求异步:

修改user操作来实现

~~constants/index.js

~~~JS
export const FETCH_USER_SUCCESS = "FETCH_USER_SUCCESS"
~~~

~~reducers/user.js

~~~js
import { FETCH_USER_SUCCESS } from "../constants"
const initialState = {
	user:{}
}
const user = ( state = initialState, action ) => {
	switch(action.type){
        case FETCH_USER_SUCCESS:
            return {
            	user:action.user
            };
        default:
            return state
    }
}
~~~

~~actions/user.js

~~~js
import { FETCH_USER_SUCCESS } from "../constants"
export function fetch_user(user){
    return {
        type:FETCH_USER_SUCCESS,
        user
    }
}
export const get_user = () => {
	fetch("http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php")
	.then(res => res.json())
	.then(data =>{
		dispatch(fetch_user(data.chengpinDetails[0]))
	})
    .catch(error => {
        console.log(error)
    })
}
~~~

~~components/user.jsx:

~~~jsx
import React from "react"
import { connect } from "react-redux"
import { bindActionCreators } from "redux"
import * as userActions from "../actions/user"

class User extends React.Component {
	render(){
        return (
            <div>
                <p>{ this.props.user.user.title }</p>
                <p>User</p>
                <botton onClick={ () => { this.props.userActions.get_user() } }>getUser</botton>
            </div>
        )
    }
}
const mapStateToProps = (state) =>{
    return {
    	user:state.user
    }
}
const mapDispatchToProps = (dispatch) =>{
    return {
        userActions:bindActionCreators(userActions.dispatch)
    }
}
export default connect(mapStateToProps,mapDispatchToProps)(User)
~~~

增加请求的失败和等待操作:

~~constants/index.js增加:

~~~jsx
export const FETCH_USER_REQUEST = "FETCH_USER_REQUEST"
export const FETCH_USER_FAILURE = "FETCH_USER_FAILURE"
~~~

~~reducers/user.js:

~~~js
import { FETCH_USER_SUCCESS, FETCH_USER_REQUEST, FETCH_USER_FAILURE} from "../constants"

const initialState = {
	user:{},
    isFetching:false,
    error:null
}
const user = ( state = initialState, action ) => {
	switch(action.type){
        case FETCH_USER_SUCCESS:
            return {
            	user:action.user,
                isFetching:false,
                error:null
            };
        case FETCH_USER_REQUEST:
            return {
            	user:{},
                isFetching:true,
                error:null
            };
        case FETCH_USER_FAILURE:
            return {
            	user:{},
                isFetching:false,
                error:action.error
            };
        default:
            return state
    }
}
~~~

~~actions/user.js

~~~js
import { FETCH_USER_SUCCESS, FETCH_USER_REQUEST, FETCH_USER_FAILURE } from "../constants"
export function fetch_user(user){
    return {
        type:FETCH_USER_SUCCESS,
        user
    }
}
export function fetch_failuse(error){
    return {
        type:FETCH_USER_FAILURE,
        error
    }
}
export function fetch_request(){
    return {
        type:FETCH_USER_REQUEST
    }
}
export const get_user = () => {
    dispatch(fetch_request())
	fetch("http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php")
	.then(res => res.json())
	.then(data =>{
		dispatch(fetch_user(data.chengpinDetails[0]))
	})
    .catch(error => {
        dispatch(fetch_failuse(error))
    })
}
~~~

~~components/user.jsx: render()中新增

~~~ jsx
const { error, isFetching, user } = this.props.user
let data;
if (error) {
    data = error
}else if(isFetching) {
    data = "Loading"
}else{
    data = user.title
}
<p>{ data }</p>
~~~

### Redux DevTools的使用

1.浏览器安装Redux DevTools插件

2.在入口index.js中

~~~jsx
import { composeWithDevTools } from "redux-devtools-extension"
const store = createStore(rootReducer, {}, composeWithDevTools(applyMiddleware(thunk)));
~~~

## 进阶

 关于渲染问题:

~~父组件中存在定时器并传值给子组件引用, 定时器监听的值每次变化父组件都会重新渲染, 子组件随父组件一起重新渲染.

优化1:子组件中加入shouldComponentUpdate生命周期进行判断

~~~jsx
shouldComponentUpdate(nextProps, nextState){
	if(nextProps.num === this.props.num){
       return false
    }
    return true
}
~~~

优化2: 子组件中使用React.PureComponent { } 继承.

~~Component:不会进行比较

~~PureComponent :对数据会进行浅比较 props

关于标签结构打乱问题:

~~使用<></>或者<Fragment></Fragment>来解决

关系深层嵌套取值问题:

~~路由的this.props.history.push("/")方法必须是路由直接子元素, 如果是孙子元素,则不能使用, 可通过prop-types传递history对象来解决

~~使用prop-types:

~~~jsx
import React from "react"
import PropTypes from "prop-types"

const Topic = ()=>{
    return(
        <div>
        	<Comment/>
        </div>
    )
}
const Comment = (props,context)=>{
    return(
        <div>
        	{ context.color }
        </div>
    )
}

export default class Demo extends React.Component{
    getChildContext(){
        return{
            color:"red"
        }
    }
    render(){
        return(
        	<div>
                <Topic/>
            </div>
        )
    }
}
Comment.contextTypes = {
    color:PropTypes.string
}
Demo.childContextTypes = {
    color:PropTypes.string
}
~~~

高阶组件:

~~是函数, 参数是一个组件, 返回值也是一个组件

~~用于子组件挂载到父组件过程中间做一层防护, 可做其他操作.

~~~jsx
import React from "react"
const withFetch = (ComposeComponent) => {
	return classextends React.Component{
        render(){
            return(
            	<ComposeComponent {...this.props}/>
            )
        }
    }
}
class MyData extends React.Component{
    render(){
        return(
        	<div>
             	MyData:{this.props.data}
            </div>
        )
    }
}

const WithFetch = withFetch(MyData);

export default class Demo extends React.Component{
	render(){
        return(
            <div>
            	<WithFetch data={"Hello WithFetch"}/>
            </div>
        )
    }
}
~~~

封装一个发送请求的高阶组件:

~~banner.jsx:

~~~jsx
import React, {Component} from "react"
const withFetch = (url) => (View) =>{
    return class extends Component{
        constructor(){
            super();
            this.state = {
				loading:true,
                data:null
            }
        }
        componentDidMount(){
            fetch(url)
            .then(res => res.json())
            .then(data => {
                this.setState({
                    loading:false,
                    data:data
                })
            })
        }
        render(){
            if(this.state.loading){
            	return(
                    <div>loading...</div>
                )   
            }else{
                return <View data={ this.state.data }></View>
            }
        }
    }
}
export default withFetch
~~~

~~NewBanner.jsx:

~~~jsx
import React from "react"
import withFetch from "../withFetch"

const Banner = withFetch("http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php")(props =>{
    return(
        <div>
            <p>
            	{ props.data.banner[0].title }
            </p>
        </div>
    )
})
~~~

~~入口Home.jsx:

~~~jsx
import React from "react"
import NewBanner from "./Demo/New/NewBanner"

function Home() {
    return (
    	<div>
        	<NewBanner />
        </div>
    )
}
export default Home
~~~

错误边界问题

~~componentDidCatch:子元素发送错误时触发

~~ErrorBoundary.jsx:用于处理错误组件

~~~jsx
import React from "react"

export default class ErrorBoundary extends React.Component{
    state = {
        hasError: false,
        error: null,
        errorInfo: null
    }
	
	componentDidCatch(error, errorInfo){
        this.setState({
            hasError:true,
            error:error,
            errorInfo:errorInfo
        })
    }
	render(){
        if(this.state.hasError){
            return 
            	<div>
                	{ this.props.render(this.state.errorInfo) }							</div>
        }
        return this.props.children;
    }
}
~~~

~~Errors.jsx:错误组件

~~~jsx
import React from "react"

export default class Errors extends React.Component{
	render(){
    	return(
            <ul>
            	{
                    null.map((element, index)=>{
                        return <li key={index}>{ element }</li>
                    })
                }
            </ul>
        )
    }
}
~~~

~~父组件Parent.jsx:

~~~jsx
import React from "react"
import Errors from "./Errors"
import ErrorBoundary from "./ErrorBoundary"

export default class Parent extends React.Component{
		state = {
          	count:0
		}
		increment = () => {
			this.setState({
                count:this.state.count+1
            })
        }
        decrement = () => {
			this.setState({
                count:this.state.count-1
            })
        }
		render(){
			return(
                <p>{ this.state.count }</p>
                <ErrorBoundary render={
                   	(error, errorInfo) => <p>{ error.toString() }</p> }
                    >
                    <Errors/>
                </ErrorBoundary>
                <button onClick={ this.increment }>Increment</button>
                <button onClick={ this.decrement }>Decrement</button>
            )
        }
}
~~~

## HOOK

 为了代码简洁,我们可以使用函数组件,但在函数组件中无法使用状态state

~~为了解决函数组件中存在的问题,HOOK诞生了

~~Demo.jsx:

~~~jsx
import React, { useState } from "react"

export default () => {
    const [count, setCount] = useState(10)
    
    return(
        <div>
        	{ count }
            <button onClick={ () => { setCount(count+1) } }></button>
        </div>
    )
}
~~~

useEffect 等于三个生命周期函数: 

useEffect方法第二个参数加[]代表组件渲染完成只执行一次

~~componentDidMount: useEffect( () => {  }, [] )

useEffect方法不加第二个参数代表state更新就会重新渲染

~~componentDidMount + componentDidUpdate: useEffect( () => {  } )

useEffect方法的回调函数里return代表组件卸载前的操作

~~componentWillUnmount: useEffect( () => { return () => {  } } )

useCallback用于优化节省不必要的渲染:

~~第二个参数决定了是否允许第一个参数执行: ()=>setCount1(count1+1)

~~如果count发送变化则允许执行, 否则则不允许执行

~~第一个参数第一次会执行, 之后才会判断第二个参数是否发生变化

~~~jsx
import React, { useState, useCallback } from "react"

const Demo = () => {
    const [ count, setCount ] = useState(0);
    const [ count1, setCount1 ] = useState(0);
    function clickHandler(){
        setCount(count+1)
    }
    return(
        <div>
            <p>{ count }</p>
            <button onClick={ clickHandler }>Click</button>
            <p>{ count1 }</p>
            <button onClick={ useCallback(()=>setCount1(count1+1), 						[count]) }>Click
            </button>
        </div>
    )
}
~~~

useReducer类似于redux

~~~jsx
import React, { useState, useReducer } from "react"
 const initialState = { count:0 }
 function reducer(state, action){
     switch(action.type){
         case "increment":
             return { count:state.count+1 }
         case "decrement":
             return { count:state.count-1 }
         default:
             throw new Error();
            }
 }
function Counter(){
    const [state, dispatch] = useReducer(reducer, initialState)
    return(
        <div>
        	Count{ state.count }
            <button onClick={ () => dispatch({ type:"increment" }) }>+</button>
            <button onClick={ () => dispatch({ type:"decrement" }) }>-</button>
        </div>
    )
}
~~~

useContext

~~可用于父子传值

~~父组件

~~~jsx
import React from "react"
import ChildPage from "./ChildPage"

export const MyContext = React.createContext();

function MainPage(){
    return(
        <div>
        	<MyContext.Provider value="Hello React useContext">
                <ChildPage />
            </MyContext.Provider>
        </div>
    )
}
export default MainPage
~~~

~~子组件

~~~jsx
import React, { useContext } from "react"
import { MyContext } from "./MainPage"

function ChildPage(){
    return(
        <p>{ useContext(MyContext) }</p>
    )
}
export default ChildPage
~~~

contextType

~~useContext的扩展

~~~jsx
import React, { createContext } from "react"

const ThemeContext = createContext();

export default class Demo extends React.Cpmponent{
    state = {
        theme: red
    }
	
	render(){
        const { theme } = this.state
        return(
            <div>
                <ThemeContext.Provider value={ theme }>										<Middle></Middle>
                </ThemeContext.Provider>
            </div>
        )
    }
}
class Middle extends React.Cpmponent{
    render(){
        return(
        	<div>
                <Bottom></Bottom>
            </div>
        )
    }
}
//原方式:
class Bottom extends React.Cpmponent{
    render(){
        return(
        	<div>
                <ThemeContext.Consumer>
                	{
                         theme => <h1>{ theme }</h1>
                    }
                </ThemeContext.Consumer>
            </div>
        )
    }
}
//contextType方式:
class Bottom extends React.Cpmponent{
    static contextType = ThemeContext
    render(){
        const theme = this.context
        return(
        	<div>
               	<h1>{ theme }</h1>
            </div>
        )
    }
}
~~~

对于setState的理解

~~在生命周期函数中是异步的

~~合并所以的异步执行,然后异步执行完毕后,才会执行异步的回调

## TS结合React

props与state的使用:

~~Hello.tsx

~~~tsx
import * as React from "react"

interface IProps {
    title:string,
    age:number,
    onMyClick:any
}
interface IState {
    count:number
}
export default class Hello extends React.Component<IProps, IState>{
    public constructor(props:IProps){
        super(props);
        this.state = {
        	count:1000
        }
        this.clickHandler = this.clickHandler.bind(this)
        this.clickMsgHandler = this.clickMsgHandler.bind(this)
    }
    
    public clickHandler(){
    	this.setState({
            count:2000
        })
    }
    
    pubilc clickMsgHandler(){
        this.props.onMyClick("chid msg")
    }
    
    public render(){
        const { title, age } = this.props
        return(
            <div>
                <div>{ title }{ age }</div>
                <div>
                	{this.state.count}
                    <button onClick={ this.clickHandler }>按钮</button>
                    <button onClick={ this.clickMsgHandler }>
                        按钮							
                    </button>
                </div>
            </div>
        )
        
    }
}

~~~

~~App.tsx

~~~tsx
import * as React from "react"
import Hello from "./components/Hello"
 class App extends React.Component{
     
     public myClickHandler(data:string){
         console.log(data)
     }
     
     public render(){
		return(
            <div>
            	<Hello title="标题" age={20} onMyClick={ 									this.myClickHandler }/>
            </div>
        )	
     }
 }
~~~



# Nuxt

## 项目配置

新版本npx create-nuxt-app nuxt-name

旧版本npx create-nuxt-app@2.15.0 nuxt-name

新版本否决了server安装选项, 需要自行安装server端如koa

新版本的运行命令均为nuxt

具体修改参照:

~~~json
{
  "name": "app",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "cross-env NODE_ENV=development nodemon server/index.js --watch server --exec babel-node",
    "build": "nuxt build && backpack build",
    "start": "cross-env NODE_ENV=production node build/main.js --exec babel-node",
    "precommit": "npm run lint",
    "lint:js": "eslint --ext .js,.vue --ignore-path .gitignore .",
    "lint": "npm run lint:js"
  },
  "dependencies": {
    "@nuxtjs/axios": "^5.12.2",
    "babel-cli": "^6.26.0",
    "babel-core": "^6.26.3",
    "babel-preset-es2015": "^6.24.1",
    "babel-preset-stage-0": "^6.24.1",
    "consola": "^2.15.0",
    "core-js": "^3.6.5",
    "cross-env": "^5.2.0",
    "element-ui": "^2.13.2",
    "koa": "^2.5.2",
    "koa-router": "^10.0.0",
    "nuxt": "^2.14.6"
  },
  "devDependencies": {
    "@nuxtjs/eslint-config": "^3.1.0",
    "@nuxtjs/eslint-module": "^2.0.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^7.10.0",
    "eslint-config-prettier": "^6.12.0",
    "eslint-plugin-nuxt": "^1.0.0",
    "eslint-plugin-prettier": "^3.1.4",
    "node-sass": "^5.0.0",
    "prettier": "^2.1.2",
    "sass-loader": "^10.1.0"
  }
}

~~~

server入口文件:

~~~js
import Koa from 'koa'
import { Nuxt, Builder } from 'nuxt'
import consola from 'consola'
async function start() {
  const app = new Koa()
  const host = process.env.HOST || '127.0.0.1'
  const port = process.env.PORT || 9000

  // Import and Set Nuxt.js options
  const config = require('../nuxt.config.js')
  config.dev = !(app.env === 'production')

  // Instantiate nuxt.js
  const nuxt = new Nuxt(config)

  // Build in development
  if (config.dev) {
    const builder = new Builder(nuxt)
    await builder.build()
  }
  app.use((ctx) => {
    ctx.status = 200
    ctx.respond = false // Mark request as handled for Koa
    ctx.req.ctx = ctx // This might be useful later on, e.g. in nuxtServerInit or with nuxt-stash
    nuxt.render(ctx.req, ctx.res)
  })

  app.listen(port, host)
  consola.ready({
    message: `Server listening on http://${host}:${port}`,
    badge: true,
  }) // eslint-disable-line no-console
}

start()

~~~

使用import引入需配置babel:

~~~json
{
  "presets": ["es2015","stage-0"]
}
~~~



## 项目结构

 .nuxt                            *// Nuxt自动生成，临时的用于编辑的文件，build*

assets                           *// 用于组织未编译的静态资源入LESS、SASS 或 JavaScript*

components                       *// 用于自己编写的Vue组件，比如滚动组件，日历组件，分页组件*

layouts                          *// 布局目录，用于组织应用的布局组件，不可更改。*

middleware                       *// 用于存放中间件*

pages                            *// 用于存放写的页面，我们主要的工作区域*

plugins                          *// 用于存放JavaScript插件的地方*

static                           *// 用于存放静态资源文件，比如图片*

store                            *// 用于组织应用的Vuex 状态管理。*

.editorconfig                    *// 开发工具格式配置*

.eslintrc.js                     *// ESLint的配置文件，用于检查代码格式*

.gitignore                       // 配置git不上传的文件

nuxt.config.json          // 用于组织Nuxt.js应用的个性化配置，已覆盖默认配置

packagelock.json        // npm自动生成，用于帮助package的统一性设置的，yarn也有相同的操作

package.json                     *// npm包管理配置文件*



## 配置详解

- 字段 `mode`：

  - `mode: 'universal',`
  - nuxt 项目的开发模式，默认是 `universal` （SSR服务端渲染），但是呢，它还有一个值，是`spa` ，就是我们常说的单页面应用，使用nuxt是可以构建单页面应用的，类似于使用`vue-cli`脚手架工具的创建`spa`项目

- 字段 `head`：

  - 这个head呢，就是我们的项目页面的header部分，这些配置会在head标签里面生成对应的`meta`，`link`等标签，这里默认的title是我们项目package.json的默认name，描述呢，也是我们项目默认的 description ; 这里的hid属性，是我们的id标识符，用于区分相同name的meta标签， 这里的Link 是我们项目的ico，默认的 `/` 地址，是我们的static目录下地址

  ```js
  head: {
      title: process.env.npm_package_name || '',
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { hid: 'description', name: 'description', content: process.env.npm_package_description || '' }
      ],
      link: [
        { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }
      ]
  }
  ```

- 字段 `loading`:

  - `loading: { color: '#fff' }`
  - 目录项目页面切换，默认的加载配置
  - 在页面切换的时候，Nuxt.js 使用内置的加载组件显示加载进度条。我们可以定制它的样式，禁用或者创建自己的加载组件。

  ```js
    export default {
      mounted () {
        this.$nextTick(() => {
          this.$nuxt.$loading.start()
          setTimeout(() => this.$nuxt.$loading.finish(), 500)
        })
      }
    }
  ```

  - 禁用加载进度条

  ```js
    module.exports = {
      loading: false
    }
  ```

- 字段 `css` :

  - 存放样式文件，可以在项目的全局加载出来，可以放置一些全局的而一些浏览器默认样式

- 字段 `plugins`: <Array[String|Object]>

  - 使用方式

  ```js
    module.exports = {
      plugins: ['~plugins/vue-notifications']
    }
  ```

  - 然后, 我们需要创建 plugins/vue-notifications.js 文件：

  ```js
    import Vue from 'vue'
    import VueNotifications from 'vue-notifications'
  
    Vue.use(VueNotifications)
  ```

- 字段 `modules`:

  - modules是Nuxt.js扩展，可以扩展它的核心功能并添加无限的集成。
  - 参考案例：

  ```js
    export default {
      modules: [
        // Using package name
        '@nuxtjs/axios',
  
        // Relative to your project srcDir
        '~/modules/awesome.js',
  
        // Providing options
        ['@nuxtjs/google-analytics', { ua: 'X1234567' }],
  
        // Inline definition
        function () { }
      ]
    }
  ```

- 字段 `build`: <Boolean 或 Object>

  - Nuxt.js 允许我们在自动生成的 vendor.bundle.js 文件中添加一些模块，以减少应用 bundle 的体积。如果你的应用依赖第三方模块，这个配置项是十分实用的。
  - Nuxt.js 使用 webpack-bundle-analyzer 分析并可视化构建后的打包文件，你可以基于分析结果来决定如何优化它。
  - 这个配置项用来配置 Nuxt.js 项目的构建规则，即 Webpack 的构建配置，如通过 vendor 字段引入第三方模块，通过 plugin 字段配置 Webpack 插件，通过 loaders 字段自定义 Webpack 加载器等。通常我们会在 build 的 vendor 字段中引入 `axios` 模块，从而在项目中进行 HTTP 请求
  - 案例代码：

  ```js
  module.exports = {    
   build: {
     vendor: ['core-js', 'axios'],
     loaders: [
       {
         test: /\.(scss|sass)$/,
         use: [{
           loader: "style-loader"
         }, {
           loader: "css-loader"
         }, {
           loader: "sass-loader"
         }]
       },
       {
         test: /\.(png|jpe?g|gif|svg)$/,
         loader: 'url-loader',
         query: {
           limit: 1000,
           name: 'img/[name].[hash:7].[ext]'
         }
       },
       {
         test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
         loader: 'url-loader',
         query: {
           limit: 1000,
           name: 'fonts/[name].[hash:7].[ext]'
         }
       }
     ]
   }
  }
  ```

- 字段 `devModules`,

  - 类似于 `module` 字段，但只运行于开发环境，不会在线上环境构建

### SSR原理

asyncData():

​	实现SSR的方法, 将服务器端编译好的内容和获取到的数据下发过来

​	其原理是通过<script>标签在window上挂载一个NUXT对象

​	对象的内容会指明使用的模板文件与数据



fetch():

​	Vuex实现SSR的方法, 与asyncData同理.





# GO

## 环境配置

1. 下载安装GO

2. 选择放置项目的盘符创建GO文件夹, 并创建三个子文件夹, 分别为:bin, pkg, src

3. 在src下创建以你github域名和账号命名的文件夹链, 如: src\github.com\gaojianghua

4. 将环境变量中的GOPATH改为对应你创建的bin目录, 如: E:\GO

5. 将E:\GO\bin添加到path环境变量中

6. 使用vscode或者GoLand打开gaojianghua目录下新建的项目并新建一个go文件

7. 使用https://goproxy.io国内代理安装go插件,执行下方命令

   ~~~js
   go env -w GO111MODULE=on
   go env -w GOPROXY=https://goproxy.io,direct
   ~~~

8. 在vscode右下角弹出的插件安装提示中点击install all安装所有插件

9. 在GoLand设置中配置GOROOT和GOPATH以及GO Module

   - GOROOT就是GO的安装路径, 默认会自动设置上
   - GOPATH里的三个设置, 全部设置为你创建的E:\GO目录
   - GO Module中勾选启动模块集成并填上GOPROXY=https://goproxy.io,direct

10. GO命令:

    - go build -o 123.go        //编译并运行go文件
    - go install                       //编译并生成可执行文件移动到bin目录下
    - go run                            //像执行脚本文件一样执行go代码

11. 跨平台编译: (其他平台去掉S)

    - SET CGO_ENABLED=0      //禁用CGO
    - SET GOOS=linux               //目标平台是linux(在哪个平台跑就改成哪个平台)
    - SET GOARCH=amd64       //目标处理器架构是amd64







# 设计模式

## 面向对象

面向对象示例:

~~~js
function CreateCat(name) {
    this.name = name
    this.eat = function () {
        console.log(this.name + 'eat something')
    }
}

let catA = new CreateCat('catA')
let catB = new CreateCat('catB')
let catC = new CreateCat('catC')

catA.eat()
catB.eat()
catC.eat()
~~~



函数知识:

在函数执行的时候会在函数内部创建两个变量: arguments和this

arguments存储着实参的一个类数组对象

this指向函数的执行上下文



New操作符:

1.创建一个空对象

2.将构造函数的原型对象 ( prototype ) 属性赋值给新对象的原型链 ( --proto--)

3.将构造函数的this指向新对象

4.执行构造函数的代码

5.将新对象返回

模拟:

~~~js
function CreateCat(name) {
    this.name = name
    this.eat = function () {
        console.log(this.name + 'eat something')
    }
}
let cat = (function () {
    let obj = {}
    obj.__proto__ = CreateCat.prototype
    CreateCat.call(obj, 'cat')
    return obj
})()
console.log(cat.name)
~~~



### 继承

1.类式继承:

- 这种方法不支持父构造函数带参数
- 父构造函数里的方法和属性都会变成共有属性

2.构造函数继承:

- 不能继承父构造函数的原型方法

3.组合式继承:

- --proto--里面的属性没有用
- 执行了两次父构造函数

4.寄生组合式继承:

- 解决了上面三种方式的问题, 是相对完美的继承方式

~~~js
function A(name) {
    this.name = name
    this.list = [1,2,3]
}
A.prototype.getName = function () {
    console.log(this.name)
}
function SubA(name) {
    A.call(this, name)
    this.subName = 'sub' + this.name
}
function inhertPrototype(subClass, superClass){
    function F(){}
    F.prototype = superClass.prototype
    subClass.prototype = new F()
}
inhertPrototype(SubA, A)
~~~



### 多态

表示不同对象调用相同方法会产生不同结果

示例:

~~~js
function Base() {}
Base.prototype.initial = function () {
    this.init()
}
function SubA() {
    this.init = function () {
        console.log('subA init')
    }
}
function SubB() {
    this.init = function () {
        console.log('subB init')
    }
}
SubA.prototype = new Base()
SubB.prototype = new Base()
let subA = new SubA()
let subB = new SubB()
subA.init()
subB.init()
~~~



### UML类图

~~~js
class People {
    constructor(name, house) {
        this.name = name
        this.house = house
    }
    saySomething(){

    }
}
class A extends People{
    constructor(name, house) {
        super(name, house);
    }
    saySomething() {
        alert('I am A')
    }
}
class B extends People{
    constructor(name, house) {
        super(name, house);
    }
    saySomething() {
        alert('I am B')
    }
}
class House {
    constructor(city) {
        this.city = city
    }
    showCity(){
        alert(`house in ${this.city}`)
    }
}
let aHouse = new House('北京')
let a = new A('aaa', aHouse)
console.log(a)
let b = new B('bbb')
console.log(b)
~~~

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(1).png)





## SOLID五大设计原则

S-单一职责原则

- 一个程序只做好一件事
- 如果功能过于复杂就拆分开, 每个部分保持独立

O-开放封闭原则

- 对扩展开放, 对修改封闭
- 增加需求时, 扩展新代码, 而非修改已有代码
- 这是软件设计的终极目标

L-李氏置换原则

- 子类能覆盖父类
- 父类能出现的地方子类就能出现
- JS中使用较少 ( 弱类型 & 继承使用较少 )

I-接口独立原则

- 保持接口的单一独立, 避免出现"胖接口"
- JS中没有接口 ( TS例外 ) , 使用较少
- 类似于单一职责原则, 这里只关注接口

D-依赖导致原则

- 面向接口编程, 依赖于抽象而不依赖于具体
- 使用方只关注接口而不关注具体类的实现
- JS中使用较少 ( 没有接口 & 弱类型 )

举例:

- 单一职责原则: 每个then中的逻辑只做好一件事
- 开放封闭原则: 如果新增需求, 扩展then

~~~js
function loadImg(src) {
    let promise = new Promise(function (resolve,reject) {
        let img = document.createElement('img')
        img.onload = function () {
            resolve(img)
        }
        img.onerror = function () {
            reject('图片加载失败')
        }
        img.src = src
    })
    return promise
}
let src = 'https://img.com'
let result = loadImg(src)
result.then(function (img) {
    alert(`width: ${img.width}`)
    return img
}).then(function (img) {
    alert(`height: ${img.height}`)
}).catch(function (er) {
    alert(er)
})
~~~



## 设计模式汇总

创建型

1. 工厂模式 ( 工厂方法模式, 抽象工厂模式, 建造者模式 )

2. 单例模式

3. 原型模式

组合型

1. 适配器模式

2. 装饰器模式

3. 代理模式

4. 外观模式

5. 桥接模式

6. 组合模式

7. 享元模式

行为型

1. 策略模式
2. 模板方法模式
3. 观察者模式
4. 迭代器模式
5. 职责链模式
6. 命令模式
7. 备忘录模式
8. 状态模式
9. 访问者模式
10. 中介者模式
11. 解释器模式



## 工厂模式

普通示例:

~~~js
function createPerson(name){
    let a = {}
    a.name = name
    a.getName =  function () {
        console.log(this.name)
    }
    return a
}
let person = createPerson('高江华')
person.getName()
console.log(person.name)
~~~

进阶示例:

~~~js
function Person(name){
    this.name = name
}
Person.prototype.getName = function () {
    console.log(this.name)
}
function Car(model){
    this.model = model
}
Car.prototype.getModel = function () {
    console.log(this.model)
}
function Create(type, param) {
    if (this instanceof Create){
        return new this[type](param)
    } else {
        return new Create(type, param)
    }

}
Create.prototype = {
    person: Person,
    car: Car
}
let person = new Create('person', '高江华')
let car = Create('car', '灰太狼')
person.getName()
car.getModel()
~~~

类示例:

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(6).png)

~~~js
class Product{
    constructor(name) {
        this.name = name
    }
    init(){
        alert('init')
    }
    fun1(){
        alert('fun1')
    }
    fun2(){
        alert('fun2')
    }
}
class Creator{
    create(name){
        return new Product(name)
    }
}
let creator = new Creator()
let p = creator.create('p1')
p.init()
~~~

 

## 建造模式

普通示例:

~~~js
let data = [
    {
        name: '高 江华',
        age: 25,
        work: 'engineer'
    },
    {
        name: '灰 太狼',
        age: 25,
        work: 'teacher'
    },
    {
        name: '红 太狼',
        age: 25,
        work: 'xxx'
    }
]
function CandiDate (param) {
    let candiDate = {}
    candiDate.name = param.name
    console.log(param.name)
    candiDate.age = param.age
    candiDate.firstName = candiDate.name.split(' ')[0]
    candiDate.lastName = candiDate.name.split(' ')[1]
    candiDate.work = {}
    switch (param.work) {
        case 'engineer':
            candiDate.work.name = '工程师'
            candiDate.work.description = '热爱编程'
            break
        case 'teacher':
            candiDate.work.name = '老师'
            candiDate.work.description = '乐于分享'
            break
        default:
            candiDate.work.name = param.work
            candiDate.work.description = '无'
    }
    candiDate.work.changeWork = function (work) {
        this.name = work
    }
    candiDate.work.changeDes = function (des) {
        this.description = des
    }
    return candiDate
}
let candiDateArr = []
for (let i = 0; i < data.length; i++){
    candiDateArr[i] = CandiDate(data[i])
}
console.log(candiDateArr[0])
candiDateArr[0].work.changeWork('xxx')
console.log(candiDateArr[0].work)
~~~

进阶示例:

~~~js
let data = [
    {
        name: '高 江华',
        age: 25,
        work: 'engineer'
    },
    {
        name: '灰 太狼',
        age: 25,
        work: 'teacher'
    },
    {
        name: '红 太狼',
        age: 25,
        work: 'xxx'
    }
]
function CandiDate (param) {
    let candiDate = new Person(param)
    candiDate.name = new CreateName(param.name)
    candiDate.work = new CreateWork(param.work)
    return candiDate
}
function Person(param) {
    this.name = param.name
    this.age = param.age
}
function CreateName(name) {
    this.wholeName = name
    this.firstName = name.split(' ')[0]
    this.secondNaem = name.split(' ')[1]
}
function CreateWork(work) {
    switch (work) {
        case 'engineer':
            this.name = '工程师'
            this.description = '热爱编程'
            break
        case 'teacher':
            this.name = '老师'
            this.description = '乐于分享'
            break
        default:
            this.name = work
            this.description = '无'
    }
    CreateWork.prototype.changeWork = function (work) {
        this.name = work
    }
    CreateWork.prototype.changeDes = function (des) {
        this.description = des
    }
}
let candiDateArr = []
for (let i = 0; i < data.length; i++){
    candiDateArr[i] = CandiDate(data[i])
}
console.log(candiDateArr[0])
candiDateArr[0].work.changeWork('xxx')
console.log(candiDateArr[0].work)
~~~



## 单例模式

~~~js
let createSingle = (function () {
    let unique = null
    function single() {
        return {
            a: 1
        }
    }

    return function () {
        if (unique === null) {
            unique = single()
        }
        return unique
    }
})()
let a = createSingle()
let b = createSingle()
console.log(a === b)
~~~

## 装饰模式

~~~js
function Car() {
    this.price = 10
}
function carLeft(carClass) {
    carClass.hasHeatSeat = true
    carClass.price += 2
}
function carRight(carClass) {
    carClass.hasAutoMirror = true
    carClass.price += 0.8
}
let car = new Car()
console.log(car.price)
carLeft(car)
carRight(car)
console.log(car.price)
~~~

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(10).png)



~~~js
class Circle {
    draw(){
        console.log('画一个圆')
    }
}
class Decorator {
    constructor(circle) {
        this.circle = circle
    }
    draw(){
        this.circle.draw()
        this.setRedBorder(circle)
    }
    setRedBorder(circle){
        console.log('设置红色边框')
    }
}
let circle = new Circle()
circle.draw()
let dec = new Decorator(circle)
dec.draw()
~~~

es7装饰器

~~~js
function dec(isDec) {
    return function (target) {
        target.isDec = isDec
    }
}
@dec(false)
class Demo{
    
}
alert(Demo.isDec)
~~~



## 观察模式

~~~js
let msgCenter = (function () {
    let msg = {} //存消息
    return {
        //订消息
        register: function (type, fn) {
            if (msg[type]){
                msg[type].push(fn)
            }else {
                msg[type] = [fn]
            }
        },
        //发消息
        fire: function (type, args) {
            if (!msg[type]){
                return
            }
            let event = {
                type: type,
                args: args || {}
            }
            for (let i = 0; i < msg[type].length; i++) {
                msg[type][i](event)
            }
        },
        //取消订阅消息
        cancel: function (type, fn) {
            if (!msg[type]) {
                return
            }
            for (let i = 0; i < msg[type].length; i++) {
                if (msg[type][i] === fn) {
                    msg[type].splice(i, 1)
                    break
                }
            }
        }
    }
})()
function Person() {
    this.alreadyRegister = {}
}
Person.prototype.register = function (type, fn) {
    if (this.alreadyRegister[type]) {
        console.log('您已订阅,请不要重复订阅')
    }else {
        msgCenter.register(type,fn)
        this.alreadyRegister[type] = fn
    }
}
Person.prototype.cancel = function (type) {
    msgCenter.cancel(type, this.alreadyRegister[type])
    delete this.alreadyRegister[type]
}
let person1 = new Person()
let person2 = new Person()
let person3 = new Person()
person1.register('carInfo', function (e) {
    console.log('person1:' + e.type + e.args.info)
})
person1.register('newInfo', function (e) {
    console.log('person1:' + e.type + e.args.info)
})
person2.register('carInfo', function (e) {
    console.log('person1:' + e.type + e.args.info)
})
person3.register('newInfo', function (e) {
    console.log('person1:' + e.type + e.args.info)
})
person3.cancel('newInfo')

msgCenter.fire('carInfo', {info: '新款汽车上市'})
msgCenter.fire('newInfo', {info: '国家领导人访华'})
~~~



## 适配模式

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(7).png)

~~~js
class Adaptee {
    specificRequest(){
        return '德国标准插头'
    }
}
class Target{
    constructor() {
        this.adaptee = new Adaptee()
    }
    request(){
        let info = this.adaptee.specificRequest()
        return `${info} -> 转换器 -> 中国标准插头`
    }
}
let target = new Target()
target.request()
~~~



## 代理模式

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(9).png)



~~~js
class ReadImg{
    constructor(filename) {
        this.fileName = filename
        this.loadFromDisk()
    }
    display(){
        console.log('display...' + this.fileName)
    }
    loadFromDisk(){
        console.log('loading...' + this.fileName)
    }
}
class ProxyImg {
    constructor(fileName) {
        this.realImg = new ReadImg(fileName)
    }
    display(){
        this.realImg.display()
    }
}
let proxyImg = new ProxyImg('1.png')
proxyImg.display()
~~~

jquery代理

~~~js
$('#div1').click(function(){
	setTimeout($.proxy(function(){
        $(this).css('background-color', 'yellow')
    }, this), 1000)
})
~~~

es6代理

~~~js
let star = {
    name: '高江华',
    age: 25,
    phone: '15257184434'
}
let agent = new Proxy(star, {
    get: function (target, key) {
        if (key === 'phone'){
            return '16899997777'
        }
        if (key === 'price'){
            return 120000
        }
        return target[key]
    },
    set: function (target, key, val) {
        if (key === 'customPrice'){
            if (val < 100000){
                throw new Error('价格太低')
            }else {
                target[key] = val
                return true
            }
        }
    }
})
console.log(agent.name)
console.log(agent.age)
console.log(agent.phone)
console.log(agent.price)
agent.customPrice = 150000
console.log(agent.customPrice)
~~~



## 迭代模式

- 顺序访问一个集合
- 使用者无需知道集合内部结构

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(11).png)

~~~js
class Iterator{
    constructor(container) {
        this.list = container.list
        this.index = 0
    }
    next(){
        if (this.hasNext()){
            return this.list[this.index++]
        }
        return null
    }
    hasNext(){
        return this.index < this.list.length;
    }
}
class Container {
    constructor(list) {
        this.list = list
    }
    getIterator(){
        return new Iterator(this)
    }
}
let arr = [1,2,3,4,5]
let container = new Container(arr)
let iterator = container.getIterator()
while (iterator.hasNext()){
    console.log(iterator.next())
}
~~~

es6中的Iterator

~~~js
Array.prototype[Symbol.iterator]().next()
//原型对象下有Symbol.iterator方法执行后会得到一个迭代器
//迭代器的原型链上有一个next()方法
//执行next()方法,若value为undefined,done为true表示遍历完成
~~~

~~~js
function each(data){
    let iterator = data[Symbol.iterator]()
    let item = {done: false}
    while (!item.done){
        item = iterator.next()
        if (!item.done){
            console.log(item.value)
        }
    }
}
//简化
function each(data){
    for(let item of data){
    	console.log(item)
    }
}
let arr = [1,2,3,4,5]
let m = new Map()
m.set('a', 100)
m.set('b', 200)
each(arr)
each(m)
~~~



## 状态模式

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(12).png)



~~~js
class State {
    constructor(color) {
        this.color = color
    }
    handle(context){
        console.log(this.color)
        context.setState(this)
    }
}
class Context {
    constructor() {
        this.state = null
    }
    getState(){
        return this.state
    }
    setState(state){
        this.state = state
    }
}
let context = new Context()
let green = new State('green')
let yellow = new State('yellow')
let red = new State('red')
green.handle(context)
console.log(context.getState())
yellow.handle(context)
console.log(context.getState())
red.handle(context)
console.log(context.getState())
~~~



## 中介模式

~~~JS
class A{
    constructor() {
        this.number = 0
    }
    setNumber(num, m){
        this.number = num
        if (m){
            m.setB()
        }
    }
}
class B {
    constructor() {
        this.number = 0
    }
    setNumber(num, m){
        this.number = num
        if (m){
            m.setA()
        }
    }
}
class Mediator {
    constructor(a, b) {
        this.a = a
        this.b = b
    }
    setB(){
        let number = this.a.number
        this.b.setNumber(number * 100)
    }
    setA(){
        let number = this.b.number
        this.b.setNumber(number / 100)
    }
}
let a = new A()
let b = new B()
let m = new Mediator(a, b)
a.setNumber(100, m)
console.log(a.number, b.number)
b.setNumber(100, m)
console.log(a.number, b.number)
~~~



## 原型模式

~~~js
let prototype = {
    getName:function () {
        return this.first + ' ' + this.last
    },
    say:function () {
        alert('hello')
    }
}
let x = Object.create(prototype)
x.first = 'A'
x.last = 'B'
alert(x.getName())
x.say()
let y = Object.create(prototype)
y.first = 'C'
y.last = 'D'
alert(y.getName())
y.say()
~~~



## 桥接模式

~~~~js
class Color {
    constructor(name) {
        this.name = name
    }
}
class Shape {
    constructor(name, color) {
        this.name = name
        this.color = color
    }
    draw(){
        console.log(this.color.name, this.name)
    }
}
let red = new Color('red')
let yellow = new Color('yellow')
let circle = new Shape('circle', red)
circle.draw()
let triangle = new Shape('triangle', yellow)
triangle.draw()
~~~~

## 策略模式

~~~js
class User {
    constructor(type) {
        this.type = type
    }
    buy(){
        if (this.type === 'ordinary'){
            console.log('普通用户')
        }else if (this.type === 'member'){
            console.log('会员用户')
        }else if (this.type === 'vip'){
            console.log('vip用户')
        }
    }
}
let u1 = new User('ordinary')
u1.buy()
let u2 = new User('member')
u2.buy()
let u3 = new User('vip')
u3.buy()

//策略优化
class OrdinaryUser {
    buy(){
        console.log('普通用户')
    }
}
class MemberUser {
    buy(){
        console.log('会员用户')
    }
}
class VipUser {
    buy(){
        console.log('vip用户')
    }
}
let u1 = new OrdinaryUser()
u1.buy()
let u2 = new MemberUser()
u2.buy()
let u3 = new VipUser()
u3.buy()
~~~



## 命令模式

~~~js
class Receiver {
    exec(){
        console.log('执行')
    }
}
class Command{
    constructor(receiver) {
        this.receiver = receiver
    }
    cmd(){
        console.log('执行命令')
        this.receiver.exec()
    }
}
class Invoker{
    constructor(command) {
        this.command = command
    }
    invoke(){
        console.log('开始')
        this.command.cmd()
    }
}
let soldier = new Receiver()
let trumpeter = new Command(soldier)
let general = new Invoker(trumpeter)
general.invoke()
~~~



## 备忘模式

~~~js
class Editor {
    constructor() {
        this.content = null
    }
    setContent(content){
        this.content = content
    }
    getContent(){
        return this.content
    }
    saveContentToMemento(){
        return new Memento(this.content)
    }
    getContentFromMemento(memento){
        this.content = memento.getContent()
    }
}
let editor = new Editor()
let careTaker = new CareTaker()
editor.setContent('111')
editor.setContent('222')
careTaker.add(editor.saveContentToMemento())
editor.setContent('333')
careTaker.add(editor.saveContentToMemento())
editor.setContent('444')

console.log(editor.getContent())
editor.getContentFromMemento(careTaker.get(1))
console.log(editor.getContent())
editor.getContentFromMemento(careTaker.get(0))
console.log(editor.getContent())
~~~







## 面试题

第一题:

- 打车时, 可以打专场和快车, 任何车都有车牌和名称
- 不同车价格不同, 快车每公里1元, 专车每公里2元
- 行程开始时, 显示车辆信息
- 行程结束时, 显示打车金额 ( 假定行程为5公里 )

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(3).png)

~~~js
class Car {
    constructor(number, name) {
        this.number = number
        this.name = name
    }
}
class Kuaiche extends Car{
    constructor(number, name) {
        super(number, name);
        this.price = 1
    }
}
class Zhuanche extends Car{
    constructor(number, name) {
        super(number, name);
        this.price = 2
    }
}
class Trip {
    constructor(car) {
        this.car = car
    }
    start(){
        console.log(`行程开始, 名称: ${this.car.name},
            车牌号: ${this.car.number}`)
    }
    end(){
        console.log('行程结束, 价格: ' + (this.car.price * 5))
    }
}
let car = new Kuaiche(100, '桑塔纳')
let trip = new Trip(car)
trip.start()
trip.end()
~~~



第二题

- 某停车场,分3层,每层100车位
- 每个车位都能监控到车辆的驶入和离开
- 车辆进入前,显示每层的空余车位数量
- 车辆进入时,摄像头可识别车牌号和时间
- 车辆出来时, 出口显示器显示车牌号和停车时长

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/1%20(5).png)

~~~js
class Car {
    constructor(num) {
        this.num = num
    }
}
class Camera {
    shot(car){
        return{
            num: car.num,
            inTime: Date.now()
        }
    }
}
class Screen {
    show(car, inTime){
        console.log('车牌号', car.num)
        console.log('停车时间', Date.now() - inTime)
    }
}
class Park {
    constructor(floors) {
        this.floors = floors || []
        this.camera = new Camera()
        this.screen = new Screen()
        this.carList = {}
    }
    in(car){
        const info = this.camera.shot(car)
        const i = parseInt(Math.random() * 100 % 100)
        const place = this.floors[0].places[i]
        place.in()
        info.place = place
        this.carList[car.num] = info
    }
    out(car){
        const info = this.carList[car.num]
        const place = info.place
        place.out()
        this.screen.show(car, info.inTime)
        delete this.carList[car.num]
    }
    emptyNum(){
        return this.floors.map(floor => {
            return `${floor.index} 层还有 ${floor.emptyPlaceNum()} 个空闲车位`
        }).join('\n')
    }
}
class Floor{
    constructor(index, places) {
        this.index = index
        this.places = places || []
    }
    emptyPlaceNum(){
        let num = 0
        this.places.forEach(p => {
            if (p.empty){
                num = num + 1
            }
        })
        return num
    }
}
class Place{
    constructor() {
        this.empty = true
    }
    in(){
        this.empty = false
    }
    out(){
        this.empty = true
    }
}
const floors = []
for (let i = 0; i < 3; i++){
    const places = []
    for (let j = 0; j < 100; j++){
        places[j] = new Place()
    }
    floors[i] = new Floor(i+1, places)
}
const park = new Park(floors)
const car1 = new Car(100)
const car2 = new Car(200)
const car3 = new Car(300)
console.log('第一辆车进入')
console.log(park.emptyNum())
park.in(car1)
console.log('第二辆车进入')
console.log(park.emptyNum())
park.in(car2)
console.log('第一辆车离开')
park.out(car1)
console.log('第二辆车离开')
park.out(car2) 
console.log('第三辆车进入')
console.log(park.emptyNum())
park.in(car3)
~~~



# web安全

## XSS

Cross Site Scripting

跨站脚本攻击

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210120093829316.png)

- 获取页面数据
- 获取Cookies
- 劫持前端逻辑
- 发送请求
- 偷取用户资料
- 偷取网站任意数据
- 偷取用户密码和登录态
- 欺骗用户



### 反射型攻击

通过url参数直接注入

例如: 在网址url后面加入<script>脚本, 便会执行该脚本内容

​		获使用src属性链接远端脚本进行攻击



### 存储型攻击

存储到DB后读取时注入

例如: 在文章底部发表评论带上<script>脚本, 那么该条评论会存储到数据库中

​		将该文章网址发给其他用户, 只要打开网址便会中招



### 攻击注入点

- HTML节点内容
- HTML属性
- JavaScript代码
- 富文本



### 防御手段

1. 转义html标签括号

~~~js
let escapeHtml = function (str) {
  str = str.replace(/</g, '&lt;')
  str = str.replace(/>/g, '&gt;')
  return str
}
//在可能出现攻击注入的节点用该方法进行转义
~~~

2. 转义html属性引号与空格

~~~js
let escapeProperty = function (str) {
  if (!str)return ''
  str = str.replace(/"/g, '&quto;')
  str = str.replace(/'/g, '&#39;')
  str = str.replace(/ /g, '&#32;')
  return str
}
~~~

3. 使用JSON.stringfy方法转义解决js代码注入

4. 使用XSS库去转义

5. CSP

   - Content-Security-Policy

   - 内容安全策略
   - 用于指定哪些内容可以执行

   ~~~js
   //在http头中设置来源:Content-Security-Policy
   child-src//页面子内容 如iframa子页面
   connect-src//网络链接 如ajax请求
   default-src//默认链接 其他链接没有指定就找该链接
   font-src//字体
   frame-src//框架
   img-src//图片
   manifest-src//webapp的信息
   media-src//音频视频
   object-src//插件之类的
   script-src//脚本
   style-src//样式
   worker-src//可允许多个源
   //信任来源
   <host-source>//来自哪个主机域名
   <scheme-source>//来自哪种协议
   'self'//与页面同域的
   'unsafe-inline'//直接插入在页面中的内容 如xss攻击
   'unsafe-eval'//信任调用eval函数
   'none'//不信息任何来源
   'nonce-<base64-value>'//指定一次性的匹配内容,匹配才执行
   <hash-source>//后端指定哈希,前端匹配哈希才执行
   'strict-dynamic'//指定信任脚本中又访问的其他脚本和地址是否信任
   //设置http头
   (`Content-Security-Policy`: `default-src 'self'`)
   ~~~

   

## CSRF

Cross Site Request Forgy

跨站请求伪造

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210120133818331.png)

- 利用用户登录态
- 用户不知情
- 完成业务请求
- 盗取用户资金
- 冒充用户发帖背锅
- 损坏网站名誉



### 防御手段

1. 禁止第三方网站带cookie, 设置same-site属性

~~~js
ctx.cookies.set('userId', user.id, {
	httpOnly:false,
	sameSite:'strict'
})
~~~

2. 使用验证码验证信息, 如ccap图形验证码库
3. 使用token验证
4. 验证http请求头中的referer

~~~js
let referer = ctx.request.headers.referer
if(!/^https?:\/\/localhost/.test(referer)){
   throw new Error('非法请求')
}
~~~



## Cookies

### 特性

- 前端数据存储
- 后端通过http头设置
- 请求时通过http头传给后端
- 前端可读写
- 遵守同源策略
- 域名 ( 可以在哪些域名可以使用 )
- 有效期
- 路径 ( 作用于网站的url哪一级 )
- http-only ( http请求和发送可以使用cookie, js不能使用 )
- secure ( 只能在https中使用cookie, http是无法使用的 )

例如: 设置有效期

~~~js
let time = new Date().toGMTString()
document.cookie = `a=1; expires=${time}`
~~~



### 作用

- 存储个性化设置
- 存储未登录时用户唯一标识
- 存储已登录用户的凭证
- 存储其他业务数据



### 安全策略

使用node的crypto模块加密

~~~js
let crypto = require('crypto')
let key = 'gaojianghua'
//加密
let cipher = crypto.createCipher('des', key)
let text = cipher.update('hello world', 'utf8', 'hex')
text += cipher.final('hex')

console.log(text)
//解密
let decipher = crypto.createDecipher('des', key)
let originalText = decipher.update(text, 'hex', 'utf8')
originalText += decipher.final('utf8')

console.log(originalText)
~~~





## 点击劫持

通过iframe标签引用真实页面并将其透明, 显示假的网页

当用户点击时, 点击的是透明的真实页面内容

sandbox可选值为允许哪种操作, 若不填值则表示禁用所有行为

sandbox="allow-forms"允许表单提交, 其他行为禁止 ( 下方防御手段js禁止内嵌代码将失效 )

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body style="background: url('123.png') no-repeat">
<iframe style="opacity: 0" src="http://localhost:3000" sandbox="allow-forms" width="800" height="600"></iframe>>
</body>
</html>
~~~



### 防御手段

1. JS脚本禁止内嵌网页

- top指向的是body页面本身
- window指向的是iframe引用页面

~~~js
if (top.location != window.location){
  top.location = window.location
}
~~~

2. X-FRAME-OPTIONS禁止内嵌

- 设置http头X-FRAME-OPTIONS

~~~js
ctx.set('X-Frame-Options', 'DENY')//禁止内嵌
//其他值
//SAMEORIGIN 嵌入页和被嵌入页在同一个域下才允许
//ALLOW-FROM http://localhost:3000 允许指定的网址内嵌
~~~





## HTTP传输窃听

http传输协议是明文传输

前端发送请求在代理服务器以及链路层中容易被窃听篡改

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210120175853132.png)



窃听

- 窃听用户密码
- 窃听传输敏感信息
- 非法获取个人资料

篡改

- 插入广告
- 重定向网站
- 无法防御的XSS和CSRF攻击



### HTTPS

通过TLS ( SSL ) 将明文加密传输到达服务器再进行解密

保证不被窃听篡改 

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210121094308431.png)



存在中间人隐患, 无法确定传输目标的身份

可能出现中间人顶替服务器来接收

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210121092419560.png)



解决中间人隐患, 使用CA证书机制

- 证书无法伪造
- 证书私钥不被泄露
- 域名管理权不泄露
- CA坚守原则

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210121100221790.png)

使用方法:

- 申请域名

- 申请证书 验证域名并下载

- 证书内容

  - ca_bundle.crt	CA证书

  - certificate.crt	个人证书
  - private.key	私钥

- 将CA与个人证书合并为fulichain.crt文件

- 开启https服务

  ~~~js
  const Koa = require('koa')
  const app = new Koa()
  const fs = require('fs')
  const https = require('https')
  
  https.createServer({
    key:fs.readFileSync('./cert/private.key'),
    cert:fs.readFileSync('./cert/fullchain.crt')
  }, app.callback()).listen(3000, function () {
    console.log('https服务已启动!')
  })
  ~~~

- 修改电脑host文件, 将127.0.0.1指向域名地址

- 最后使用域名访问即可



正式环境部署

- curl https://get.acme.sh | sh	安装脚本可申请免费证书

- cd /root/.acme.sh	进入脚本目录

- ./acme.sh --issue -d news.toobug.net --webroot /data/web/news.toobug.net/

  - ./acme.sh --issue	签发新证书
  - news.toobug.net	使用的域名
  - --webroot /data/web/news.toobug.net/	使用的web根目录

- 配置nginx: vi /etc/nginx/conf.d/news.toobug.net.conf

  ~~~nginx
  server {
      listen	80;
      listen	443 ssl http2;
      server_name	news.toobug.net;
      ssl_certificate /root/.acme.sh/news.toobug.net/fullchain.cer;
      ssl_certificate_key /root/.acme.sh/news.toobug.new/news.toobug.net.key;
      
      location / {
          root /data/web/news.toobug.net;
      }
  }
  ~~~

- 重启nginx: nginx -s reload

- 最后使用域名访问即可



## 密码安全

- 密码的作用
- 密码的存储
- 密码的传输
- 密码的替代方案
- 生物特征密码的问题

### 彩虹表

加密字典的收录, 可使用复杂的嵌套加密来对抗彩虹表

如: md5 ( 明文 )	md5( md5 ( 明文 ) )	md5 ( sha1 ( 明文 ) )	md5 ( sha256 ( sha1 ( 明文 ) ) )

使用加盐来加强密码复杂度

盐: 用户的唯一值, 由系统随机生成

如: md5 ( sha1 ( md5 ( ID+ab83kd+原始密码+81kdso+盐+1lso;$2 ) ) )



变换次数越多越安全

- 加密成本几乎不变 ( 密码生成速度会慢些 )
- 彩虹表失效 ( 数量太大, 无法建立通用性 )
- 解密成本增大N倍







# WebAssembly

WebAssembly 是一种可以使用非 JavaScript 编程语言编写代码并且能在浏览器上运行的技术方案

编程中的两种代码翻译方法

- 解释器: 翻译的过程是一行一行及时生效的
- 编译器: 编译是在执行前进行翻译

### 解释器的利弊

- 解释器很快的获取代码并且执行。不需要在可以执行代码的时候知道全部的编译步骤。因此，解释器感觉与 JavaScript 有着自然的契合。web 开发者能够立即得到反馈很重要。

- 但是实用解释器的弊端是当你运行相同的代码的时候。比如，你执行了一个循环。然后你就会一遍又一遍的做同样的事情。

### 编译器的利弊

- 编译器则有相反的效果。在程序开始的时候，它可能需要稍微多一点的时间来了解整个编译的步骤。但是当运行一个循环的时候他会更快，因为他不需要重复的去翻译每一次循环里的代码。

- 不同的浏览器实现起来稍有不同，但是基本目的是相同的。他们给 JavaScript 引擎添加了一个新的部分(JIT)，称为监视器（也称为分析器）。该监视器在 JavaScript 运行时监控代码，并记录代码片段运行的次数以及使用了那些数据类型, 如果相同的代码行运行了几次，这段代码被标记为 “warm”。如果运行次数比较多，就被标记为 “hot”。被标记为 “warm” 的代码被扔给基础编译器，只能提升一点点的速度。被标记为 “hot” 的代码被扔给优化编译器，速度提升的更多



### JavaScript运行

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210121153945999.png)

1. Parsing ( 解析 ) --> 将源码转换成解释器可以运行的东西 ( AST ) 所做的事情。

2. Compiling + optimizing ( 编译和优化 ) --> 花费在基础编译和优化编译上的时间。有一些优化编译的工作不在主线程，所以这里并不包括这些时间。

3. Re-optimizing ( 重新优化 ) --> 当预先编译优化的代码不能被优化的情况下，JIT 将这些代码重新优化，如果不能重新优化就丢给基础编译去做

4. Execution ( 执行 ) --> 执行代码的过程

5. Garbage collection ( 垃圾回收 ) --> 清理内存的时间

6. 注意:

   这些任务不会发生在离散块或特定的序列中。相反，它们将被交叉执行。比如正在做一些代码解析时，还执行着一些其他的逻辑，有些代码编译完成后，引擎又做了一些解析，然后又执行了一些逻辑，等等。

### WebAssembly运行

![](https://raw.githubusercontent.com/gaojianghua/PicGO/master/img/image-20210121154837003.png)

1. JavaScript源码被解析为抽象语法树 ( AST ) 然后转换为V8引擎的中间层字节码
2. Decode ( 解码 ) --> WebAssembly本身已经是字节码, 解码即可
3. Compiling + optimizing ( 编译和优化 ) --> 
   - JavaScript 是在执行代码期间编译的。因为 JavaScript 是动态类型语言，相同的代码在多次执行中都有可能都因为代码里含有不同的类型数据被重新编译。这样会消耗时间
   - WebAssembly 与机器代码更接近
   - 编译器不需要在运行代码时花费时间去观察代码中的数据类型，在开始编译时做优化。
   - 编译器不需要去每次执行相同代码中数据类型是否一样。
   - 更多的优化在 LLVM 最前面就已经完成了。所以编译和优化的工作很少。
4. Re-optimizing ( 重新优化 ) -->
   - JIT 基于运行代码的假设不正确时会重新优化 如: 当进入循环的变量与先前的迭代不同时，或者在原型链中插入新函数时
   - WebAssembly 中，类型是明确的，因此 JIT 不需要根据运行时收集的数据对类型进行假设。这意味着它不必经过重新优化的周期
5. Execution ( 执行 ) -->
   - 人们为了使他们的代码更易于阅读（例如：将常见任务抽象为跨类型工作的函数）会阻碍编译器优化代码
   - 执行 WebAssembly 代码通常更快。有些必须对 JavaScript 做的优化不需要用在 WebAssembly 上
   - 由于程序员不需要直接编程，WebAssembly 提供了一组更适合机器的指令。根据您的代码所做的工作，这些指令的运行速度可以在10％到800％之间
6. Garbage collection ( 垃圾回收 ) --> 
   - JavaScript因不能控制垃圾回收时机，所以它可能在非常重要的时间去工作，从而影响性能
   - WebAssembly不支持垃圾回收。内存是手动管理的（就像 C/C++）。虽然这些可能让开发者编程更困难，但它的确提升了性能
7. 补充:
   - WebAssembly 和别的汇编语言是有一些不同的。它是一个概念机上的机器语言，不是在一个真正存在的物理机上运行的机器语言
   - WebAssembly 指令有时候被称为虚拟指令。它比 JavaScript 代码更快更直接的转换成机器代码，但它们不直接和特定硬件的特定机器代码对应
   - WebAssembly模块和JS模块之间存在重大差异。目前，WebAssembly 中的函数只能使用 WebAssembly 类型（整数或浮点数）作为参数或返回值
   - 如果要在 JavaScript 和 WebAssembly 之间传递一个字符串，需要将字符转换为等效的字符码。然后你需要将它写入内存数组。由于索引是整数，所以可以将索引传递给 WebAssembly 函数。因此，字符串的第一个字符的索引可以当作指针





### 总结

1. 使用WebAssembly，可以更快地在 web 应用上运行代码。这里有 几个 WebAssembly 代码运行速度比 JavaScript 高效的原因。

2. 文件加载 - WebAssembly 文件体积更小，所以下载速度更快。

3. 解析 - 解码 WebAssembly 比解析 JavaScript 要快

4. 编译和优化 - 编译和优化所需的时间较少，因为在将文件推送到服务器之前已经进行了更多优化，JavaScript 需要为动态类型多次编译代码

5. 重新优化 - WebAssembly 代码不需要重新优化，因为编译器有足够的信息可以在第一次运行时获得正确的代码

6. 执行 - 执行可以更快，WebAssembly 指令更接近机器码

7. 垃圾回收 - 目前 WebAssembly 不直接支持垃圾回收，垃圾回收都是手动控制的，所以比自动垃圾回收效率更高





# WebRTC

### 源码目录结构

|         api         |        WebRTC接口层, 浏览器都是通过该接口调用WebRTC        |
| :-----------------: | :--------------------------------------------------------: |
|      **call**       | **数据流的管理层, Call代表同一个端点的所有数据的流入流出** |
|      **video**      |                    **与视频相关的逻辑**                    |
|      **audio**      |                    **与音频想关的逻辑**                    |
|  **common_audio**   |                      **音频算法相关**                      |
|  **common_video**   |                      **视频算法相关**                      |
|      **media**      |       **与多媒体相关的逻辑处理, 如编解码的逻辑处理**       |
|     **logging**     |                        **日志相关**                        |
|     **module**      |                  **最重要的目录, 子模块**                  |
|       **pc**        |           **Peer Connection, 连接相关的逻辑层**            |
|       **p2p**       |               **端对端相关代码, stun, turn**               |
|    **rtc_base**     |         **基础代码, 如线程, 锁相关的统一接口代码**         |
|    **rtc_tool**     |                **音视频分析相关的工具代码**                |
|   **tool_webrtc**   |         **WebRTC测试相关的工具代码, 如网络模拟器**         |
| **system_wrappers** |    **与具体操作系统相关的代码, 如CPU特性, 原子操作等**     |
|      **stats**      |                **存放各种数据统计相关的类**                |
|       **sdk**       |      **存放Android和IOS层代码, 如视频的采集, 渲染等**      |

Modules目录

|         audio_coding         |       音频编解码相关代码       |
| :--------------------------: | :----------------------------: |
|       **audio_device**       | **音频采集与音频播放相关代码** |
|       **audio_mixer**        |        **混音相关代码**        |
|     **audio_processing**     |   **音频前后处理的相关代码**   |
|    **bitrate_controller**    |      **码率控制相关代码**      |
|  **congestion_controller**   |        **流控相关代码**        |
|     **desktop_capture**      |      **桌面采集相关代码**      |
|          **pacing**          | **码率探测及平滑处理相关代码** |
| **remote_bitrate_estimator** |   **远端码率估算相关的代码**   |
|         **rtp_rtcp**         |   **rtp/rtcp协议相关的代码**   |
|      **video_capture**       |     **视频采集相关的代码**     |
|       **video_coding**       |    **视频编解码相关的代码**    |
|     **video_processing**     |   **视频前后处理相关的代码**   |



### 运行机制

轨与流:

Track ( 轨 )

MediaStream ( 媒体流 )

重要类:

MediaStream

RTCPeerConnection

RTCDataChannel

### enumerateDevices

~~~js
let ePromise = navigator.mediaDevices.enumerateDevices()
~~~

MediaDevicesInfo

| 属性     | 说明                                      |
| -------- | ----------------------------------------- |
| deviceID | 设备ID                                    |
| label    | 设备的名称                                |
| kind     | 设备的种类                                |
| groupID  | 两个设备groupID相同, 说明是同一个物理设备 |



# Node

```
    Node本身能够做到如此高性能的根本原因在于事件（event）的使用，以及对于事件监听者（listener，callback）的调用上。

    Node本身是基于事件循环机制的。

    本质上，当Node启动一个文件或者服务器后，Node实际上是运行在一个死循环中的。

    while(true) {
        ...
    }

    在这个死循环当中，Node会不断发射事件、监听事件并且执行回调逻辑。

    事件来源主要有两种：一是Node自身所发射出的事件，二是来自于Node自身所运行的环境。
    监听事件：回调都是要依附于相应的事件的。
    执行回调逻辑：本质上都是由底层来执行的。

    关于IO操作的异步执行逻辑：

    1. 同步模式：
    2. 异步模式：poll epoll

    IOCP，libuv

    Node的单线程：所谓单线程，指的是Node的逻辑执行主线程是单线程的，即JavaScript代码运行所处的线程，这是个单线程，因为JavaScript
    本身只能执行在单线程当中。

    当我们在程序中引入了某个第三方模块时，那么整体的全部执行逻辑如下所示：

    Node -> 第三方模块 -> 原生模块 -> 原生模块内部的实现 -> C++模块 -> libuv -> 线程池 -> 线程 -> 执行底层的IO操作（涉及到操作系统调用）

    当Node在执行过程中，它会判断当前的操作系统类型：

    Node完整的事件循环逻辑：

    1. 启动Node运行时
    2. 检测是否有待处理的事件
    3. 如果没有，回到循环开始
    4. 如果有，那么从事件队列中取出一个事件
    5. 判断当前这个事件有没有与之关联的事件处理器（回调）
    6. 如果没有，回到循环开始
    7. 如果有，则执行事件的回调逻辑
    8. 回到循环开始，开始新一轮的事件检测流程

    整个Node的执行过程实际上是由完整的事件循环机制 + 底层的操作系统异步IO调用 + 线程池（底层库实现或由操作系统提供）共同配合来完成的。

    对于单线程的Node来说，是否无法利用到多核的优势呢？

    对于Node主线程来说，它只能运行在一个核心上面。
    对于底层的线程池来说，他们却可以运行在多个核心上面，当然也可以同时运行，因此他们是完全可以利用到多核的优势的。
```

## http模块

服务创建以及周期事件

~~~js
const http = require('http');

const server = http.createServer(function(request, response) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello Node.js');
});

server.listen(3000, 'localhost');

server.on('listening', function() {
    console.log('Server is listening');
    // server.close();
});

server.on('connection', function() {
    console.log('Client is connected');
});

server.on('close', function() {
    console.log('Server is closed');
});

console.log('Node Server started on port 3000');
~~~

第二种方式

~~~js
const http = require('http');
const httpServer = new http.Server();

httpServer.on('request', function (request, response) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello Node.js');
});

httpServer.listen(3000, function () {
    console.log('Node Server started on port 3000');
});
~~~

当浏览器访问后端服务时返回请求头及其他版本信息

~~~js
const http = require('http');

const server = http.createServer(function (request, response) {
    let data = '';

    request.on('data', function (chunk) {
        data += chunk;
    });

    request.on('end', function () {
        let method = request.method;
        let headers = JSON.stringify(request.headers);
        let httpVersion = request.httpVersion;
        let requestUrl = request.url;

        response.writeHead(200, {'Content-Type': 'text/html'});

        let responseData = method + ", " + headers + ", " + httpVersion + ", " + requestUrl;

        response.end(responseData);
    });
});

server.listen(3000, function () {
    console.log('Node Server started on port 3000');
});
~~~

模拟发送请求

~~~js
const http = require('http');

let responseData = '';

http.request({
    'host': 'localhost',
    'port': '3000',
    'method': 'get',
    'path': '/login?username=zhangsan&password=hello'
}, function (response) {
    response.on('data', function (chunk) {
        responseData += chunk;
    });

    response.on('end', function () {
        console.log(responseData);
    });
}).end();
~~~

模拟GET请求

~~~js
const http = require('http');

let responseData = '';

http.get({
    'host': 'localhost',
    'port': '3000'
}, function(response) {
    response.on('data', function(chunk) {
        responseData += chunk;
    });

    response.on('end', function() {
        console.log(responseData);
    });
}).end();
~~~

第二种方式

~~~js
const http = require('http');

let responseData = '';

const option = {
    'host': 'localhost',
    'port': '3000'
};

const request = http.request(option);

request.on('response', function (response) {
    response.on('data', function (chunk) {
        responseData += chunk;
    });

    response.on('end', function () {
        console.log(responseData);
    });
}).end();
~~~



## url模块

获取url上的所有信息

~~~js
const url = require('url');

const urlString = 'http://www.test.com?orderId=12345';
const urlObject = url.parse(urlString);

console.log(urlObject);
~~~

配置组合成url

```js
const url = require('url');

const urlObject = {
    'host': 'www.test.com',
    'port': 80,
    'protocol': 'http',
    'search': '?order=12345',
    'query': 'order=12345',
    'path': '/'
};

let realAddress = url.format(urlObject);

console.log(realAddress);
```

通过方法组合

~~~js
const url = require('url');

const urlAddress = url.resolve('http://www.test.com', 'order');

console.log(urlAddress);
~~~



## querystring模块

转路由上的参数为对象格式

~~~js
const querystring = require('querystring');

const str = 'name=zhangsan&address=xiamen';

const obj = querystring.parse(str);

console.log(obj);
~~~

反转为路由参数格式

~~~js
const querystring = require('querystring');

const obj = {
    name: 'zhangsan',
    address: 'xiamen'
};

const result = querystring.stringify(obj);

console.log(result);
~~~



## util模块

带有高亮效果的

~~~js
const util = require('util');

const obj = {
    name: 'zhangsan',
    address: 'nanchang',
    age: 25,
    married: false,
    getAge: function () {
        return this.age;
    }
};

const str = util.inspect(obj, {
    'colors': true
});

console.log(str);
~~~



## path模块

拼接文件路径

~~~js
const path = require('path');

const outputPath = path.join(__dirname, 'myDir', 'hello.js');

console.log(outputPath);
~~~

获取文件后缀名

~~~js
const path = require('path');

const extInfo = path.extname(path.join(__dirname, 'myDir', 'hello.js'));

console.log(extInfo);
~~~

以对象格式显示文件路径的各种信息

~~~js
const path = require('path');

const filePath = '/Users/helloworld/node/test.js';

const obj = path.parse(filePath);

console.log(obj);
~~~

'..'可返回上一级目录

~~~js
const path = require('path');

const myPath = path.join('/hello', 'world', 'test/welcome', 'helloworld', '..');

console.log(myPath);
~~~





## dns模块

解析域名为IP地址

~~~js
const dns = require('dns');

const domain = 'www.sohu.com';

dns.resolve(domain, function (error, address) {
    if (error) {
        console.log(error);
        return;
    }

    console.log(address);
});
~~~

通过IP查询出域名地址

~~~js
const dns = require('dns');

dns.reverse('114.114.114.114', function (error, domain) {
    console.log(domain);
});
~~~



## 暴露方式

第一种

~~~json
var myInfo = {
    name: 'zhangsan',
    age: 20
};

var myFunction = function (inputNumber) {
    return inputNumber + 5;
};

exports.myInfo = myInfo;
exports.myFunction = myFunction;
~~~

第二种

~~~js
const myModule2 = {
    myInfo: {
        name: 'zhangsan',
        age: 20
    },

    myFunction: function (inputNumber) {
        return inputNumber + 5;
    }
};

// exports.myModule2 = myModule2;
module.exports = myModule2;
~~~





## 模拟登录

login接口获取前端路由上的参数并解析为对象格式

~~~js
const http = require('http');
const querystring = require('querystring');
const url = require('url');

const userService = require('./UserService');


const server = http.createServer(function (request, response) {
    let data = '';

    request.on('data', function (chunk) {
        data += chunk;
    });

    request.on('end', function () {
        const requestUrl = request.url;
        const requestMethod = request.method;

        if (requestUrl.includes('login') && requestMethod === 'GET') {
            const requestParams = url.parse(requestUrl);
            console.log(requestParams);

            const queryObject = querystring.parse(requestParams.query);
            console.log(queryObject);

            const loginResult = userService.login(queryObject.username, queryObject.password);
            console.log('loginResult: ' + loginResult);

            response.writeHead(200, {'Content-Type': 'text/plain'});
            response.end('username: ' + queryObject.username + ', password: ' + queryObject.password);
        }
    });
});

server.listen(3000, function () {
    console.log('Server is listening on port 3000');
});
~~~

封装用户方法

~~~js
class UserService {

    login(username, password) {
        console.log('entered UserService login method');
        console.log('info from UserService.login: ' + username + ', ' + password);

        return true;
    }
}

module.exports = new UserService();
~~~



## fs模块

```
对于fs中的绝大多数api来说，Node都提供了相同功能的两个版本：同步版本与异步版本
尽最大可能去使用异步版本
```

~~~js
const fs = require('fs');
//同步
try {
    const data = fs.readFileSync('test.txt', 'utf8');
    console.log(data);
} catch (e) {
    console.log(e);
}
//异步
fs.readFile('test.txt', 'utf8', function (error, data) {
    if (error) {
        console.log(error);
        console.log('error occured')
    } else {
        console.log(data);
    }
});

fs.writeFile('mytest.txt', 'hello world', function (error) {
    if (error) {
        console.log('write file error');
    } else {
        console.log('write file successful');
    }
});
//flag:'a'表示文件不存在为自动创建
fs.writeFile('mytest2.txt', 'mytest2, node.js\r\n', {flag: 'a'}, function (error) {
    if (error) {
        console.log('write file error');
    } else {
        console.log('write file successful');
    }
});
~~~

打开一个文件

~~~js
const fs = require('fs');

fs.open('test.txt', 'r+', function (error, fd) {
    if (error) {
        return console.error(error);
    }
    console.log('file is open');
});
~~~

打开并关闭文件

~~~js
const fs = require('fs');

fs.open('test.txt', 'r+', function (error, fd) {
    if (error) {
        return console.error(error);
    }

    console.log('file is open');

    fs.close(fd, function (error) {
        if (error) {
            console.error(error);
        }
        console.log('file is closed');
    });
});
~~~

删除文件

~~~js
const fs = require('fs');

fs.unlink('hello.txt', (error) => {
    if (error) {
        throw error;
    }

    console.log("success");
});
~~~

强制重命名并读取文件状态信息

~~~js
const fs = require('fs');

fs.rename('world.txt', 'hello.txt', (error) => {
    if (error) {
        throw error;
    }

    fs.stat('hello.txt', (error, stats) => {
        if (error) {
            throw error;
        }

        console.log(JSON.stringify(stats));
    });
});
~~~

向指定文件中添加内容

~~~js
const fs = require('fs');

fs.appendFile('info.txt', 'hello world', 'utf8', (error) => {
    if (error) {
        throw error;
    }

    console.log('success');
});
~~~

创建多级文件夹

~~~js
const fs = require('fs');

fs.mkdir('mydir/hello/world', {recursive: true}, (error) => {
    if (error) {
        throw  error;
    }

    console.log('success');
});
~~~

获取当前目录下所有文件及文件夹名称

~~~js
const fs = require('fs');

fs.readdir('./', (error, files) => {
    if (error) {
        throw error;
    }

    console.log(files);
});
~~~

判断文件或文件夹是否存在

~~~js
const fs = require('fs');

fs.access('./app.js', (error) => {
    if (error) {
        throw error;
    }

    console.log('success');
});
~~~

获取指定文件的完整路径

~~~js
const fs = require('fs');

fs.realpath('app0.js', (error, resolvedPath) => {
    if (error) {
        throw error;
    }

    console.log(resolvedPath);
});
~~~

删除文件夹, 多级文件夹

```js
const fs = require('fs');

fs.rmdir('mydir', {recursive: true}, (error) => {
    if (error) {
        throw error;
    }

    console.log('success');
});
```

创建文件读取流, 读取流的各种事件

~~~js
const fs = require('fs');

const readStream = fs.createReadStream('./app12.js', {encoding: 'utf8'});
//打开
readStream.on('open', (fd) => {
    console.log(fd);
});
//准备
readStream.on('ready', () => {
    console.log('ready');
});
//内容
readStream.on('data', (data) => {
    console.log(data);
});
//结束
readStream.on('end', () => {
    console.log('end');
});
//关闭
readStream.on('close', () => {
    console.log('close');
});
//错误
readStream.on('error', (error) => {
    console.log(error);
});
~~~

创建读取和写入流, 将读取流的目标文件内容写入到写入流的目标文件中

若文件不存在会自动创建

~~~js
const fs = require('fs');

const readStream = fs.createReadStream('./app12.js', {encoding: 'utf8'});
const writeStream = fs.createWriteStream('mytest.js', {encoding: 'utf8'});

readStream.on('data', (data) => {
    writeStream.write(data, () => {
        console.log(data);
    });
});
~~~



## buffer模块

创建缓存空间并写入内容

~~~js
const buffer = Buffer.alloc(128);

const length = buffer.write('helloworld你好', 'utf8');

console.log('byte count: ' + length);
~~~

创建时便写入内容, 比较两个缓存空间内容是否相同

相同返回0 不同返回-1

~~~js
const buffer1 = Buffer.from('hello');
const buffer2 = Buffer.from('hello');

const compareResult = buffer1.compare(buffer2);

console.log(compareResult);
~~~

通过索引加入内容, 数字对应ACSll码表中的字符

~~~js
const buffer = Buffer.alloc(3);

buffer[0] = 65;
buffer[1] = 66;
buffer[2] = 67;

console.log(buffer.toString('utf8'));
~~~

一个文字占用3个字节, buffer中存的是ACSll码值与unicode字符码

使用tostring()可以转换为对应的字符

~~~js
const str = 'abcde天';
const buffer = Buffer.from(str);

console.log(str.length);
console.log(buffer.length);

console.log(buffer);
console.log(buffer.toString('utf8'));
~~~

合并多个buffer为一个buffer

totalLength不填默认为所有buffer长度之和

若所填的字小于所有buffer长度之和会截断buffer并返回

~~~js
const buffer1 = Buffer.from('hello');
const buffer2 = Buffer.from('world');
const buffer3 = Buffer.from('welcome');
const buffer4 = Buffer.from('你好');

const bufferArray = [buffer1, buffer2, buffer3, buffer4];

const bufferResult = Buffer.concat(bufferArray, 10);

console.log(bufferResult.length);

console.log(bufferResult.toString('utf8'));
~~~

JSON格式转换buffer

~~~js
const buffer = Buffer.from('你好世界');
const jsonString = JSON.stringify(buffer);

console.log(jsonString);

const jsonObject = JSON.parse(jsonString);

console.log(jsonObject);

const buffer2 = Buffer.from(jsonObject);

console.log(buffer2.toString('utf8'));
~~~

判断是否为buffer支持的字符编码格式

~~~js
const str = 'utf8';
const str2 = 'utf-8';
const str3 = 'UTF-8';
const str4 = 'utf9';
const str5 = 'gb2312';
const str6 = 'gbk';

console.log(Buffer.isEncoding(str));	//true
console.log(Buffer.isEncoding(str2));	//true
console.log(Buffer.isEncoding(str3));	//true
console.log(Buffer.isEncoding(str4));	//false
console.log(Buffer.isEncoding(str5));	//false
console.log(Buffer.isEncoding(str6));	//false
~~~

buffer是对象类型, isBuffer判断是否为一个buffer

~~~js
const buffer = Buffer.from('hello');
const myObj = {};
const str = "aa";
const flag = true;
const count = 4;

console.log(typeof myObj);
console.log(typeof buffer);
console.log(typeof str);
console.log(typeof flag);
console.log(typeof count);

console.log(Buffer.isBuffer(myObj));	//false
console.log(Buffer.isBuffer(buffer));	//true
~~~



## net模块

创建一个net服务

方式一

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    console.log('client connected');
    console.log(socket);
});

server.listen(8888, () => {
    console.log('server is listening');
});
~~~

方式二

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    console.log('client connected');
});

server.listen(8888);

server.on('listening', () => {
    console.log('server is listening');
});
~~~

net服务的事件机制

~~~js
const net = require('net');

const server = new net.Server();

server.on('connection', (socket) => {
    console.log('client connected');
});

server.listen(8888);

server.on('listening', () => {
    console.log('server is listening');

    server.close();
});

server.on('close', () => {
    console.log('server closed');
});

server.on('error', (error) => {
    console.log('server error');
});
~~~

获取端口网络等信息

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    console.log('client connected');
});

server.listen(8888, () => {
    const address = server.address();

    console.log(address.port + ", " + address.address + ", " + address.family);
});
~~~

设置服务最大连接数

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    console.log('client connected');

    server.maxConnections = 2;

    server.getConnections((error, count) => {
        console.log('client count: ' + count);
    });
});

server.listen(8888, () => {
    console.log('server is listening');
});
~~~

data为请求连接的请求头信息

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    socket.on('data', (data) => {
        console.log(data.toString());
    });
});

server.listen(8888, () => {
    console.log('server is listening');
});
~~~

socket.bytesWritten发送的字节数

socket.bytesRead接收的字节数

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    const address = socket.address();
    const message = 'server address is ' + JSON.stringify(address);

    socket.write(message, () => {
        const writeSize = socket.bytesWritten;

        console.log(message);
        console.log('message size is: ' + writeSize);
    });

    socket.on('data', (data) => {
        console.log(data.toString());

        const readSize = socket.bytesRead;

        console.log('data size is: ' + readSize);
    });
});

server.listen(8888, () => {
    console.log('server is listening');
});
~~~

客户端连接过来的网络信息

~~~js
const net = require('net');

const server = net.createServer((socket) => {
    console.log('local port: ' + socket.localPort);
    console.log('local address: ' + socket.localAddress);
    console.log('remote port: ' + socket.remotePort);
    console.log('remote family: ' + socket.remoteFamily);
    console.log('remote address: ' + socket.remoteAddress);
});

server.listen(8888, () => {
    console.log('server is listening');
});
~~~

创建socket客户端

~~~js
const net = require('net');
const client = new net.Socket();

client.connect(8888, 'localhost', () => {
    console.log('connected to the server');
});
~~~



## dgram模块

创建一个socket服务监听9999端口

无限循环互发消息

服务端

~~~js
const dgram = require('dgram');

const message = Buffer.from('This message comes from server');

const socket = dgram.createSocket('udp4', (msg, info) => {
    //发送消息
    socket.send(message, 0, message.length, info.port, info.address, (error, bytes) => {
        if (error) {
            console.log(error);
            return;
        }

        console.log('Server has sent ' + bytes + ' bytes message');
    });
});
//监听
socket.bind(9999, 'localhost', () => {
    console.log('Server has binded to 9999');
});
//接收
socket.on('message', (msg, info) => {
    console.log('message event occured');
    console.log(msg.toString());
});
~~~

客户端

~~~js
const dgram = require('dgram');

const message = Buffer.from('This message comes from client');
const socket = dgram.createSocket('udp4');
//发送消息,第一次发送
socket.send(message, 0, message.length, 9999, 'localhost', (error, bytes) => {
    if (error) {
        console.log(error);
        return;
    }

    console.log('client has sent ' + bytes + ' bytes message');
});
//接收消息
socket.on('message', (msg, info) => {
    console.log(msg.toString())
    const message2Send = 'hello world';
    //发送消息
    socket.send(message2Send, 0, message2Send.length, 9999, 'localhost');
});
~~~



## socket.io

服务端

~~~js
const http = require('http');
const io = require('socket.io');
const fs = require('fs');

const server = http.createServer((request, response) => {
    response.writeHead(200, {'Content-Type': 'text/html'});

    if (request.url === '/') {
        fs.readFile('./client.html', 'utf8', (error, data) => {
            if (error) {
                console.log('error occured');
                return;
            } else {
                response.end(data.toString());
            }
        });
    } else {
        response.end('<html><body>Error</body></html>');
    }
});

server.listen(3000, 'localhost');

const socket = io.listen(server);

socket.on('connection', (socket) => {
    console.log('connection has been established');

    socket.on('message', (message) => {
        console.log('message: ' + message);
    });

    socket.on('disconnect', () => {
        console.log('connection has lost');
    });

    socket.emit('serverEvent', 'this is serverEvent');

    socket.on('clientEvent', (data) => {
        console.log(data.address + ", " + data.age);
    });

    socket.on('broadcastEventClient', (message) => {
        console.log(message);
        socket.broadcast.emit('broadcastEventServer', 'you are good!');
    });

    socket.send('hello client');
});
~~~

客户端

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script src="/socket.io/socket.io.js"></script>

    <script type="text/javascript">
        const socket = io('http://localhost:3000');
        //接收消息
        socket.on('message', (message) => {
            console.log('data from server: ' + message);
        });
        //断开连接
        socket.on('disconnect', () => {
            console.log('disconnect');
        });
        //接收服务端对应事件消息
        socket.on('serverEvent', (data) => {
            console.log('serverEvent: ' + data);
            //发送对应事件消息给服务端
            socket.emit('clientEvent', {address: 'taiyuan', age: 20});
        });
        //发给服务端的广播消息
        socket.emit('broadcastEventClient', 'take care');
        //接收服务端广播消息
        socket.on('broadcastEventServer', (message) => {
            console.log(message);
        });


    </script>

</head>
<body>

</body>
</html>
~~~



## events模块

~~~js
const http = require('http');
const events = require('events');

const httpServer = http.createServer();
//设置最大事件监听器
httpServer.setMaxListeners(2);

httpServer.on('request', (request, response) => {
    if (request.url === '/') {
        console.log('addListener');
        response.end('end');
    }
});

const listener = (request, response) => {
    if (request.url === '/') {
        console.log('hello world');
        response.end('welcome');
    }
};

const listener2 = (request, response) => {
    if (request.url === '/') {
        console.log('hello world');
        response.end('welcome');
    }
};

const listener3 = (request, response) => {
    if (request.url === '/') {
        console.log('hello world');
        response.end('welcome');
    }
};
//默认每个事件最多注册10个监听器
console.log('default max listener count: ' + events.EventEmitter.defaultMaxListeners);

httpServer.on('request', listener);
httpServer.on('request', listener2);
httpServer.on('request', listener3);


httpServer.listen(3000, () => {
    console.log('listening to port 3000');
});
~~~

单个事件的多次触发监听

~~~js
const EventEmitter = require('events');
const emitter = new EventEmitter();

emitter.on('myEvent', function myListener() {
    console.log('myListener');
});

emitter.on('myEvent', function myListener2(param1, param2) {
    console.log(`myListener2: ${param1}, ${param2}`);
});

emitter.on('myEvent', function myListener3(...params) {
    const values = params.join(', ');
    console.log(`myListener3: ${values}`);
});

console.log(emitter.listeners('myEvent'));

emitter.emit('myEvent', 'a', 'b', 'c', 'd', 'e', 'f');
~~~

emitter.once只触发一次并且下单触发时会先移除该事件

~~~js
const EventEmitter = require('events');
const emitter = new EventEmitter();
//单次监听一个新事件
emitter.once('newListener', (event, listener) => {
    if (event === 'myEvent') {
        //接收事件
        emitter.on('myEvent', () => {
            console.log('hello');
        });
    }
});

emitter.on('myEvent', () => {
    console.log('world');
});

emitter.emit('myEvent');
~~~



## process模块

进程信息及事件监听

~~~js
console.log(process.version);

console.log(process.versions);

console.log(process.platform);

console.log(process.execPath);

console.log(process.config);

console.log(process.pid);

console.log(process.title);

console.log(process.arch);

console.log(process.memoryUsage());

console.log(process.cwd());

process.chdir('../');

console.log(process.cwd());

console.log(process.env);

// process.env.NODE_ENV = 'dev'

console.log(process.uptime());

process.on('exit', () => {
    console.log('node process exited');
});

// process.exit(0);

process.on('beforeExit', () => {
    console.log('node process before exited');
});

process.on('uncaughtException', (error) => {
    console.log(error);
    console.log('=======');
    console.log('uncaughtException occured');
});

process.on('SIGINT', () => {
    console.log('received SIGINT info');
});

setTimeout(() => {
    console.log('timeout');
}, 100000);
~~~



nextTick会在异步之前执行

~~~js
const fs = require('fs');

const myFunction = () => {
    console.log('myFunction invoked');
};
//nextTick会在异步之前执行
process.nextTick(myFunction);
//同步读取
console.log(fs.readFileSync('./app1.js').toString('utf8'));
//异步读取
fs.readFile('./app1.js', (error, data) => {
    console.log(data.toString('utf8'));
});
~~~



## child_process模块

创建子进程执行命令

```js
const childProcess = require('child_process');
//创建子进程执行命令
const lsChildProcess = childProcess.spawn('cmd', ['-al', './']);

lsChildProcess.stdout.on('data', (data) => {
    console.log(data.toString());
    //子进程的pid
    console.log(`child process id: ${lsChildProcess.pid}`);
});
//关闭事件
lsChildProcess.on('exit', (code, signal) => {
    console.log(code);
});
```

创建子进程执行node运行其他文件

~~~js
const childProcess = require('child_process');

const nodeChildProcess = childProcess.spawn('node', ['app2']);

nodeChildProcess.stdout.on('data', (data) => {
    console.log(data.toString());
    console.log(`child process id: ${nodeChildProcess.pid}`);
});

nodeChildProcess.on('exit', (code, signal) => {
    console.log(code);
});
~~~

silent: true 只获取接收到的消息: 下面只输出welcome

此为./app5.js代码

~~~js
[1, 2, 3, 4, 5].forEach(i => {
    console.log(i);
});
//接收
process.on('message', (message) => {
    console.log(message);
//发送
    process.send('welcome');
});
~~~

此为执行子进程命令代码

~~~js
const childProcess = require('child_process');
//在子进程中运行
const forkProcess = childProcess.fork('./app5', {silent: true});
//接收消息
forkProcess.on('message', (message) => {
    console.log(message);
});
//发送消息
forkProcess.send('hello world');
~~~



exec执行命令

~~~js
const childProcess = require('child_process');

childProcess.exec('node app7', (error, stdout, stderr) => {
    if (error) {
        console.log(error);
        throw error;
    } else {
        console.log(stdout.toString());
    }
});

//app7代码
['hello', 'world', 'hello world', 'welcome'].forEach((str) => {
    console.log(str);
});
~~~

execFile执行命令

~~~js
const childProcess = require('child_process');

childProcess.execFile('node', ['app9'], (error, stdout, stderr) => {
    if (error) {
        console.log(error);
        throw error;
    } else {
        console.log(stdout.toString());
    }
});
//app9代码
const addFunction = (a, b) => {
    return a + b;
};

console.log(addFunction(5, 8));
~~~

## os与cluster模块

操作系统与集群

~~~js
const cluster = require('cluster');
const http = require('http');
const os = require('os');

const cpuCount = os.cpus().length;
console.log(cpuCount)

//cluster.schedulingPolicy = cluster.SCHED_RR;

/*
    Master - Worker 模式
 */
//是否为主线程
if (cluster.isMaster) {
    for (let i = 0; i < cpuCount; ++i) {
        cluster.fork();//启动工作进程
    }
    //工作进程关闭时触发
    cluster.on('exit', (worker, code, signal) => {
        console.log(worker.process.pid);
    })
} else {
    const httpServer = http.createServer((request, response) => {
        let data = '';

        request.on('data', (chunk) => {
            data += chunk;
        });

        request.on('end', () => {
            response.writeHead(200, {'Content-Type': 'text/plain'});

            response.end(`${process.pid}`);
        });
    });

    httpServer.listen(3000, () => {
        console.log('listening to port 3000');
    });
}
~~~



## koa特性

洋葱模型

~~~js
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
    console.log('myFunction started');
    await next();
    console.log('myFunction finished');
});

app.use(async (ctx, next) => {
    console.log('myFunction2 started');
    await next();
    console.log('myFunction2 finished');
});


app.use(async (ctx, next) => {
    console.log('myFunction3 started');
    await next();
    console.log('myFunction3 finished');
});

app.use(async (ctx) => {
    // ctx.body = 'Hello Koa';

    ctx.response.type = 'text/html';
    ctx.response.body = '<h2>Hello Koa</h2>';
});

app.listen(3000);
~~~

服务监听与接口数据传输的简单实现

~~~js
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx) => {
    ctx.response.type = 'application/json';

    const responseBody = {
        result: {
            code: 0,
            description: 'success'
        }, data: {
            username: 'zhangsan',
            address: 'taiyuan',
            age: 20
        }
    };

    ctx.body = JSON.stringify(responseBody);
});

app.listen(4000);
~~~





# WebPack

## 安装配置

npm init :	初始化 package.json

npm install webpack webpack-cli -g :	全局安装webpack

npm install webpack webpack-cli -D :	当前项目下安装webpacks



## 核心概念

### Entry

入口: 指示webpack以哪个文件为入口起点开始打包, 分析构建内部依赖图



### Output

输出: 指示webpack打包后的资源bundles输出到哪里去, 以及如何命名



### Loader

让webpack能过去处理那些非JavaScript文件 ( webpack自身只理解JavaScript )



### Plugins

插件: 可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 

一直到重新定义环境中的变量等



### Mode

模式: 指示webpack使用相应模式的配置

选项一:

- 选项: development
- 描述: 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development
- 启用: NamedChunksPlugin 和 NamedModulesPlugin。
- 特点: 能让代码本地调试运行的环境

选项二:

- 选项: production

- 描述: 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production

- 启用: 

  1. FlagDependencyUsagePlugin

  2. FlagIncludedChunksPlugin
  3. ModuleConcatenationPlugin
  4. NoEmitOnErrorsPlugin
  5. OccurrenceOrderPlugin
  6. SideEffectsFlagPlugin
  7. TerserPlugin

- 特点: 能让代码优化上线 运行的环境

























